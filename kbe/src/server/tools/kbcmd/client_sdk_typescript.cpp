// Copyright 2008-2018 Yolo Technologies, Inc. All Rights Reserved. https://www.comblockengine.com

#include "kbcmd.h"
#include "client_sdk.h"
#include "client_sdk_typescript.h"	
#include "entitydef/entitydef.h"
#include "entitydef/scriptdef_module.h"
#include "entitydef/property.h"
#include "entitydef/method.h"
#include "entitydef/datatype.h"
#include "network/fixed_messages.h"

namespace KBEngine {	

static std::string headerBody = "/*\n\tGenerated by KBEngine!\n\tPlease do not modify this file!\n#REPLACE#\ttools = kbcmd\n*/\n\n";
static std::string moduleSuffix = "Base";

//-------------------------------------------------------------------------------------
ClientSDKTypeScript::ClientSDKTypeScript():
	ClientSDK(),
	initBody_()
{
}

//-------------------------------------------------------------------------------------
ClientSDKTypeScript::~ClientSDKTypeScript()
{

}

//-------------------------------------------------------------------------------------
std::string ClientSDKTypeScript::typeToType(const std::string& type)
{
	if (type == "INT8")
	{
		return "number";
	}
	else if (type == "INT16")
	{
		return "number";
	}
	else if (type == "INT32")
	{
		return "number";
	}
	else if (type == "INT64")
	{
		return "bigint";
	}
	else if (type == "UINT8")
	{
		return "number";
	}
	else if (type == "UINT16")
	{
		return "number";
	}
	else if (type == "UINT32")
	{
		return "number";
	}
	else if (type == "UINT64")
	{
		return "bigint";
	}
	else if (type == "FLOAT")
	{
		return "number";
	}
	else if (type == "DOUBLE")
	{
		return "number";
	}
	else if (type == "STRING")
	{
		return "string";
	}
	else if (type == "UNICODE")
	{
		return "string";
	}
	else if (type == "PYTHON")
	{
		return "Uint8Array";
	}
	else if (type == "PY_DICT")
	{
		return "Uint8Array";
	}
	else if (type == "PY_TUPLE")
	{
		return "Uint8Array";
	}
	else if (type == "PY_LIST")
	{
		return "Uint8Array";
	}
	else if (type == "BLOB")
	{
		return "Uint8Array";
	}
	else if (type == "ARRAY")
	{
		return "Array";
	}
	else if (type == "FIXED_DICT")
	{
		return "Map";
	}
#ifdef CLIENT_NO_FLOAT
	else if (type == "VECTOR2")
	{
		return "Vector2Int";
	}
	else if (type == "VECTOR3")
	{
		return "Vector3Int";
	}
	else if (type == "VECTOR4")
	{
		return "Vector4Int";
	}
#else
	else if (type == "VECTOR2")
	{
		return "Vector2";
	}
	else if (type == "VECTOR3")
	{
		return "Vector3";
	}
	else if (type == "VECTOR4")
	{
		return "Vector4";
	}
#endif
	else if (type == "ENTITYCALL")
	{
		return "Uint8Array";
	}

	return type;
}


//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::saveFile(bool overwrite)
{
	bool done = false;

	
	if (sourcefileName_.size() > 0)
	{
		if (KBCMD::creatDir(currSourcePath_.c_str()) == -1)
		{
			ERROR_MSG(fmt::format("creating directory error! path={}\n", currSourcePath_));
			return false;
		}

		std::string path = currSourcePath_ + sourcefileName_;

		DEBUG_MSG(fmt::format("ClientSDK::saveFile(): {}\n",
			path));

		FILE* fp;

		if (sourcefileName_ == "KBEngine.ts") {
			fp = fopen(path.c_str(), "a");
		}
		else {
			fp = fopen(path.c_str(), "w");
		}

		if (NULL == fp)
		{
			ERROR_MSG(fmt::format("ClientSDK::saveFile(): fopen error! {}\n",
				path));

			return false;
		}

		int written = fwrite(sourcefileBody_.c_str(), 1, sourcefileBody_.size(), fp);
		if (written != (int)sourcefileBody_.size())
		{
			ERROR_MSG(fmt::format("ClientSDK::saveFile(): fwrite error! {}\n",
				path));

			fclose(fp);
			return false;
		}

		if (fclose(fp))
		{
			ERROR_MSG(fmt::format("ClientSDK::saveFile(): fclose error! {}\n",
				path));

			return false;
		}

		done = true;
	}

	return done;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::create(const std::string& path)
{
	basepath_ = path;

	if (basepath_[basepath_.size() - 1] != '\\' && basepath_[basepath_.size() - 1] != '/')
		basepath_ += "/";

	currHeaderPath_ = currSourcePath_ = basepath_;

	std::string findpath = "sdk_templates/client/" + name();

	std::string getpath = Resmgr::getSingleton().matchPath(findpath);

	if (getpath.size() == 0 || findpath == getpath)
	{
		ERROR_MSG(fmt::format("ClientSDK::create(): not found path({})\n",
			findpath));

		return false;
	}

	if (!copyPluginsSourceToPath(getpath))
		return false;

	if (!writeServerErrorDescrsModule())
		return false;

	if (!writeEngineMessagesModule())
		return false;

	if (!writeTypes())
		return false;

	if (!writeEntityDefsModule())
		return false;

	const EntityDef::SCRIPT_MODULES& scriptModules = EntityDef::getScriptModules();
	EntityDef::SCRIPT_MODULES::const_iterator moduleIter = scriptModules.begin();
	for (; moduleIter != scriptModules.end(); ++moduleIter)
	{
		ScriptDefModule* pScriptDefModule = (*moduleIter).get();

		if (!writeEntityModule(pScriptDefModule))
			return false;

		if (!writeEntityCall(pScriptDefModule))
			return false;
	}

	return true;
}



//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypes()
{
	sourcefileName_ = sourcefileBody_ = "";
	headerfileName_ = headerfileBody_ = "";

	onCreateTypeFileName();

	if (!writeTypesBegin())
		return false;

	const DataTypes::DATATYPE_MAP& dataTypes = DataTypes::dataTypes();
	const DataTypes::DATATYPE_ORDERS& dataTypesOrders = DataTypes::dataTypesOrders();
	DataTypes::DATATYPE_ORDERS::const_iterator oiter = dataTypesOrders.begin();

	for (; oiter != dataTypesOrders.end(); ++oiter)
	{
		DataTypes::DATATYPE_MAP::const_iterator iter = dataTypes.find((*oiter));

		std::string typeName = iter->first;

		if (typeName[0] == '_')
			continue;

		DataType* pDataType = iter->second.get();

		if (pDataType->type() == DATA_TYPE_FIXEDDICT)
		{
			FixedDictType* pFixedDictType = static_cast<FixedDictType*>(pDataType);

			if (!writeTypeBegin(typeName, pFixedDictType))
				return false;

			FixedDictType::FIXEDDICT_KEYTYPE_MAP& keyTypes = pFixedDictType->getKeyTypes();
			FixedDictType::FIXEDDICT_KEYTYPE_MAP::iterator itemIter = keyTypes.begin();
			for (; itemIter != keyTypes.end(); ++itemIter)
			{
				std::string type = itemIter->second->dataType->getName();
				std::string itemTypeName = itemIter->first;
				std::string itemTypeAliasName = itemIter->second->dataType->aliasName();

				if (type == "INT8")
				{
					if (!writeTypeItemType_INT8(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "INT16")
				{
					if (!writeTypeItemType_INT16(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "INT32")
				{
					if (!writeTypeItemType_INT32(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "INT64")
				{
					if (!writeTypeItemType_INT64(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "UINT8")
				{
					if (!writeTypeItemType_UINT8(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "UINT16")
				{
					if (!writeTypeItemType_UINT16(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "UINT32")
				{
					if (!writeTypeItemType_UINT32(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "UINT64")
				{
					if (!writeTypeItemType_UINT64(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "FLOAT")
				{
					if (!writeTypeItemType_FLOAT(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "DOUBLE")
				{
					if (!writeTypeItemType_DOUBLE(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "STRING")
				{
					if (!writeTypeItemType_STRING(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "UNICODE")
				{
					if (!writeTypeItemType_UNICODE(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "PYTHON")
				{
					if (!writeTypeItemType_PYTHON(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "PY_DICT")
				{
					if (!writeTypeItemType_PY_DICT(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "PY_TUPLE")
				{
					if (!writeTypeItemType_PY_TUPLE(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "PY_LIST")
				{
					if (!writeTypeItemType_PY_LIST(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "BLOB")
				{
					if (!writeTypeItemType_BLOB(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "ARRAY")
				{
					if (!writeTypeItemType_ARRAY(itemTypeName, itemTypeAliasName, itemIter->second->dataType))
						return false;
				}
				else if (type == "FIXED_DICT")
				{
					if (!writeTypeItemType_FIXED_DICT(itemTypeName, itemTypeAliasName, itemIter->second->dataType))
						return false;
				}
#ifdef CLIENT_NO_FLOAT
				else if (type == "VECTOR2")
				{
					if (!writeTypeItemType_VECTOR2(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "VECTOR3")
				{
					if (!writeTypeItemType_VECTOR3(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "VECTOR4")
				{
					if (!writeTypeItemType_VECTOR4(itemTypeName, itemTypeAliasName))
						return false;
				}
#else
				else if (type == "VECTOR2")
				{
					if (!writeTypeItemType_VECTOR2(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "VECTOR3")
				{
					if (!writeTypeItemType_VECTOR3(itemTypeName, itemTypeAliasName))
						return false;
				}
				else if (type == "VECTOR4")
				{
					if (!writeTypeItemType_VECTOR4(itemTypeName, itemTypeAliasName))
						return false;
				}
#endif
				else if (type == "ENTITYCALL")
				{
					if (!writeTypeItemType_ENTITYCALL(itemTypeName, itemTypeAliasName))
						return false;
				}
			}

			if (!writeTypeEnd(typeName, pFixedDictType))
				return false;
		}
		else if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
		{
			FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

			if (!writeTypeBegin(typeName, pFixedArrayType, fmt::format("{}<#REPLACE#>", typeToType("ARRAY"))))
				return false;

			std::string type = pFixedArrayType->getDataType()->getName();
			std::string itemTypeAliasName = pFixedArrayType->getDataType()->aliasName();

			if (type == "ARRAY")
			{
				std::string newType;
				getArrayType(pFixedArrayType->getDataType(), newType);
				strutil::kbe_replace(headerfileBody_, "#REPLACE#", newType);
				strutil::kbe_replace(sourcefileBody_, "#REPLACE#", newType);
			}
			else if (type == "FIXED_DICT")
			{
				strutil::kbe_replace(headerfileBody_, "#REPLACE#", itemTypeAliasName);
				strutil::kbe_replace(sourcefileBody_, "#REPLACE#", itemTypeAliasName);
			}
			else
			{
				std::string newType = typeToType(type);
				strutil::kbe_replace(headerfileBody_, "#REPLACE#", newType);
				strutil::kbe_replace(sourcefileBody_, "#REPLACE#", newType);
			}

			std::string::size_type fHeaderPos = headerfileBody_.find("#REPLACE#");
			std::string::size_type fSourcePos = sourcefileBody_.find("#REPLACE#");
			KBE_ASSERT((fHeaderPos == std::string::npos) || (fSourcePos == std::string::npos));

			if (!writeTypeEnd(typeName, pFixedArrayType))
				return false;
		}
		else
		{
			if (!writeTypeBegin(typeName, pDataType))
				return false;

			if (!writeTypeItemType_AliasName(typeName, pDataType->getName()))
				return false;

			if (!writeTypeEnd(typeName, pDataType))
				return false;
		}
	}

	if (!writeTypesEnd())
		return false;


	if (!writeCustomDataTypesBegin())
		return false;

	const DataTypes::UID_DATATYPE_MAP& customDataTypes = DataTypes::uid_dataTypes();
	DataTypes::UID_DATATYPE_MAP::const_iterator customDtiter = customDataTypes.begin();
	for (; customDtiter != customDataTypes.end(); ++customDtiter)
	{
		const DataType* customDataTypes = customDtiter->second;

		if (customDataTypes->aliasName()[0] == '_')
			continue;

		if (!writeCustomDataType(customDataTypes))
			return false;
	}
	if (!writeCustomDataTypesEnd())
		return false;


	return saveFile();
}



//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityCall(ScriptDefModule* pScriptDefModule)
{
	sourcefileName_ = sourcefileBody_ = "";
	headerfileName_ = headerfileBody_ = "";

	onEntityCallModuleFileName(pScriptDefModule->getName());

	if (!writeEntityCallBegin(pScriptDefModule))
		return false;

	std::string newModuleName;

	// 先写BaseEntityCall
	if (!writeBaseEntityCallBegin(pScriptDefModule))
		return false;

	{
		ScriptDefModule::METHODDESCRIPTION_MAP& scriptMethods = pScriptDefModule->getBaseMethodDescriptions();
		ScriptDefModule::METHODDESCRIPTION_MAP::iterator methodIter = scriptMethods.begin();
		for (; methodIter != scriptMethods.end(); ++methodIter)
		{
			MethodDescription* pMethodDescription = methodIter->second;

			if (!pMethodDescription->isExposed())
				continue;

			if (!writeEntityCallMethodBegin(pScriptDefModule, pMethodDescription, "#REPLACE_FILLARGS1#", "#REPLACE_FILLARGS2#", BASEAPP_TYPE))
				return false;

			std::string::size_type fHeaderPos = headerfileBody_.find("#REPLACE_FILLARGS1#");
			std::string::size_type fSourcePos = sourcefileBody_.find("#REPLACE_FILLARGS1#");
			KBE_ASSERT((fHeaderPos != std::string::npos) || (fSourcePos != std::string::npos));

			std::string argsBody1 = "";
			std::string argsBody2 = "";

			std::vector<DataType*>& argTypes = pMethodDescription->getArgTypes();
			std::vector<DataType*>::iterator iter = argTypes.begin();

			int i = 1;

			for (; iter != argTypes.end(); ++iter)
			{
				DataType* pDataType = (*iter);

				argsBody2 += fmt::format("arg{}, ", i);

				if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
				{
					FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

					std::string argsTypeBody;
					if (!writeEntityMethodArgs_ARRAY(pFixedArrayType, argsTypeBody, pFixedArrayType->aliasName()))
					{
						return false;
					}

					argsBody1 += fmt::format("arg{}:{}{}, ", i++, (datatype2nativetype(argsTypeBody) == "" ? "KBETypes." : ""), argsTypeBody);
				}
				else if (pDataType->type() == DATA_TYPE_FIXEDDICT)
				{
					FixedDictType* pFixedDictType = static_cast<FixedDictType*>(pDataType);

					std::string argsTypeBody = typeToType(pFixedDictType->aliasName());
					if (!writeEntityMethodArgs_Const_Ref(pDataType, argsTypeBody))
					{
						return false;
					}

					argsBody1 += fmt::format("arg{}:{}{}, ", i++, (datatype2nativetype(argsTypeBody) == "" ? "KBETypes." : ""), argsTypeBody);
				}
				else if (pDataType->type() != DATA_TYPE_DIGIT)
				{
					std::string argsTypeBody = typeToType(pDataType->getName());
					if (!writeEntityMethodArgs_Const_Ref(pDataType, argsTypeBody))
					{
						return false;
					}

					argsBody1 += fmt::format("arg{}:{}{}, ", i++, (datatype2nativetype(argsTypeBody) == "" ? "KBETypes." : ""), argsTypeBody);
				}
				else
				{
					argsBody1 += fmt::format("arg{}:{}{}, ", i++, (datatype2nativetype(pDataType->getName()) == "" ? "KBETypes." : ""), typeToType(pDataType->getName()));
				}
			}

			if (argsBody1.size() > 0)
			{
				argsBody1.erase(argsBody1.size() - 2, 2);
				argsBody2.erase(argsBody2.size() - 2, 2);

				argsBody2 = std::string(", ") + argsBody2;
			}

			strutil::kbe_replace(headerfileBody_, "#REPLACE_FILLARGS1#", argsBody1);
			strutil::kbe_replace(headerfileBody_, "#REPLACE_FILLARGS2#", argsBody2);
			strutil::kbe_replace(sourcefileBody_, "#REPLACE_FILLARGS1#", argsBody1);
			strutil::kbe_replace(sourcefileBody_, "#REPLACE_FILLARGS2#", argsBody2);

			if (!writeEntityCallMethodEnd(pScriptDefModule, pMethodDescription))
				return false;
		}
	}

	if (!writeBaseEntityCallEnd(pScriptDefModule))
		return false;

	headerfileBody_ += fmt::format("\n");
	sourcefileBody_ += fmt::format("\n");

	// 再写CellEntityCall
	if (!writeCellEntityCallBegin(pScriptDefModule))
		return false;

	{
		ScriptDefModule::METHODDESCRIPTION_MAP& scriptMethods = pScriptDefModule->getCellMethodDescriptions();
		ScriptDefModule::METHODDESCRIPTION_MAP::iterator methodIter = scriptMethods.begin();
		for (; methodIter != scriptMethods.end(); ++methodIter)
		{
			MethodDescription* pMethodDescription = methodIter->second;

			if (!pMethodDescription->isExposed())
				continue;

			if (!writeEntityCallMethodBegin(pScriptDefModule, pMethodDescription, "#REPLACE_FILLARGS1#", "#REPLACE_FILLARGS2#", CELLAPP_TYPE))
				return false;

			std::string::size_type fHeaderPos = headerfileBody_.find("#REPLACE_FILLARGS1#");
			std::string::size_type fSourcePos = sourcefileBody_.find("#REPLACE_FILLARGS1#");
			KBE_ASSERT((fHeaderPos != std::string::npos) || (fSourcePos != std::string::npos));

			std::string argsBody1 = "";
			std::string argsBody2 = "";

			std::vector<DataType*>& argTypes = pMethodDescription->getArgTypes();
			std::vector<DataType*>::iterator iter = argTypes.begin();

			int i = 1;

			for (; iter != argTypes.end(); ++iter)
			{
				DataType* pDataType = (*iter);

				argsBody2 += fmt::format("arg{}, ", i);

				if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
				{
					FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

					std::string argsTypeBody;
					if (!writeEntityMethodArgs_ARRAY(pFixedArrayType, argsTypeBody, pFixedArrayType->aliasName()))
					{
						return false;
					}

					argsBody1 += fmt::format("arg{}:{}{}, ", i++, (datatype2nativetype(argsTypeBody) == "" ? "KBETypes." : ""), argsTypeBody);
				}
				else if (pDataType->type() == DATA_TYPE_FIXEDDICT)
				{
					FixedDictType* pFixedDictType = static_cast<FixedDictType*>(pDataType);

					std::string argsTypeBody = typeToType(pFixedDictType->aliasName());
					if (!writeEntityMethodArgs_Const_Ref(pDataType, argsTypeBody))
					{
						return false;
					}

					argsBody1 += fmt::format("arg{}:{}{}, ", i++, (datatype2nativetype(argsTypeBody) == "" ? "KBETypes." : ""), argsTypeBody);
				}
				else if (pDataType->type() != DATA_TYPE_DIGIT)
				{
					std::string argsTypeBody = typeToType(pDataType->getName());
					if (!writeEntityMethodArgs_Const_Ref(pDataType, argsTypeBody))
					{
						return false;
					}

					argsBody1 += fmt::format("arg{}:{}{}, ", i++, (datatype2nativetype(argsTypeBody) == "" ? "KBETypes." : ""), argsTypeBody);
				}
				else
				{
					argsBody1 += fmt::format("arg{}:{}{}, ", i++, (datatype2nativetype(pDataType->getName()) == "" ? "KBETypes." : ""), typeToType(pDataType->getName()));
				}
			}

			if (argsBody1.size() > 0)
			{
				argsBody1.erase(argsBody1.size() - 2, 2);
				argsBody2.erase(argsBody2.size() - 2, 2);

				argsBody2 = std::string(", ") + argsBody2;
			}

			strutil::kbe_replace(headerfileBody_, "#REPLACE_FILLARGS1#", argsBody1);
			strutil::kbe_replace(headerfileBody_, "#REPLACE_FILLARGS2#", argsBody2);
			strutil::kbe_replace(sourcefileBody_, "#REPLACE_FILLARGS1#", argsBody1);
			strutil::kbe_replace(sourcefileBody_, "#REPLACE_FILLARGS2#", argsBody2);

			if (!writeEntityCallMethodEnd(pScriptDefModule, pMethodDescription))
				return false;
		}
	}

	if (!writeCellEntityCallEnd(pScriptDefModule))
		return false;

	if (!writeEntityCallEnd(pScriptDefModule))
		return false;

	return saveFile();
}



//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityMethods(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule)
{
	sourcefileBody_ += "\n";
	headerfileBody_ += "\n";

	ScriptDefModule::METHODDESCRIPTION_MAP& clientMethods = pCurrScriptDefModule->getClientMethodDescriptions();
	ScriptDefModule::METHODDESCRIPTION_MAP::iterator methodIter = clientMethods.begin();
	for (; methodIter != clientMethods.end(); ++methodIter)
	{
		MethodDescription* pMethodDescription = methodIter->second;
		if (!writeEntityMethod(pEntityScriptDefModule, pCurrScriptDefModule, pMethodDescription, "#REPLACE#"))
			return false;

		std::string::size_type fHeaderPos = headerfileBody_.find("#REPLACE#");
		std::string::size_type fSourcePos = sourcefileBody_.find("#REPLACE#");
		KBE_ASSERT((fHeaderPos != std::string::npos) || (fSourcePos != std::string::npos));

		std::string argsBody = "";

		std::vector<DataType*>& argTypes = pMethodDescription->getArgTypes();
		std::vector<DataType*>::iterator iter = argTypes.begin();

		int i = 1;

		for (; iter != argTypes.end(); ++iter)
		{
			DataType* pDataType = (*iter);

			if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
			{
				FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

				std::string argsTypeBody;
				if (!writeEntityMethodArgs_ARRAY(pFixedArrayType, argsTypeBody, pFixedArrayType->aliasName()))
				{
					return false;
				}

				std::string nativetype = datatype2nativetype(argsTypeBody);

				if (nativetype == "") {
					argsBody += fmt::format("arg{}:KBETypes.{}, ", i++, argsTypeBody);
				}
				else {
					argsBody += fmt::format("arg{}:{}, ", i++, argsTypeBody);
				}
			}
			else if (pDataType->type() == DATA_TYPE_FIXEDDICT)
			{
				FixedDictType* pFixedDictType = static_cast<FixedDictType*>(pDataType);

				std::string argsTypeBody = typeToType(pFixedDictType->aliasName());
				if (!writeEntityMethodArgs_Const_Ref(pDataType, argsTypeBody))
				{
					return false;
				}

				std::string nativetype = datatype2nativetype(argsTypeBody);

				if (nativetype == "") {
					argsBody += fmt::format("arg{}:KBETypes.{}, ", i++, argsTypeBody);
				}
				else {
					argsBody += fmt::format("arg{}:{}, ", i++, argsTypeBody);
				}
			}
			else if (pDataType->type() != DATA_TYPE_DIGIT)
			{
				std::string argsTypeBody = typeToType(pDataType->getName());
				if (!writeEntityMethodArgs_Const_Ref(pDataType, argsTypeBody))
				{
					return false;
				}
				std::string nativetype = datatype2nativetype(argsTypeBody);

				if (nativetype == "") {
					argsBody += fmt::format("arg{}:KBETypes.{}, ", i++, argsTypeBody);
				}
				else {
					argsBody += fmt::format("arg{}:{}, ", i++, argsTypeBody);
				}

			}
			else
			{
				std::string nativetype = datatype2nativetype(pDataType->getName());
				if (nativetype == "") {
					argsBody += fmt::format("arg{}:KBETypes.{}, ", i++, typeToType(pDataType->getName()));
				}
				else {
					argsBody += fmt::format("arg{}:{}, ", i++, typeToType(pDataType->getName()));
				}

			}
		}

		if (argsBody.size() > 0)
		{
			argsBody.erase(argsBody.size() - 2, 2);
		}

		strutil::kbe_replace(headerfileBody_, "#REPLACE#", argsBody);
		strutil::kbe_replace(sourcefileBody_, "#REPLACE#", argsBody);
	}

	return true;
}

//-------------------------------------------------------------------------------------
void ClientSDKTypeScript::onCreateTypeFileName()
{
	//sourcefileName_ = "KBETypes.ts";
	sourcefileName_ = "KBEngine.ts";
}

//-------------------------------------------------------------------------------------
void ClientSDKTypeScript::onCreateEntityModuleFileName(const std::string& moduleName)
{
	sourcefileName_ = moduleName + moduleSuffix + ".ts";
}

//-------------------------------------------------------------------------------------
void ClientSDKTypeScript::onCreateServerErrorDescrsModuleFileName()
{
	sourcefileName_ = "ServerErrorDescrs.ts";
}

//-------------------------------------------------------------------------------------
void ClientSDKTypeScript::onCreateEngineMessagesModuleFileName()
{
	sourcefileName_ = "Messages.ts";
}

//-------------------------------------------------------------------------------------
void ClientSDKTypeScript::onCreateDefsCustomTypesModuleFileName()
{
	sourcefileName_ = "KBEngine.ts";
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeServerErrorDescrsModuleBegin()
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");


	sourcefileBody_ += R"delimiter(
export class ServerErr {
	name: string;
	descr: string;
	id: number;
}


export class ServerErrorDescrs {
	public static serverErrs: Map<number, ServerErr> = new Map<number, ServerErr>();


	constructor() {
)delimiter";
	
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeServerErrorDescrsModuleErrDescr(int errorID, const std::string& errname, const std::string& errdescr)
{
	/*sourcefileBody_ += fmt::format("\t\t\t{{\n\t\t\t\tServerErr e;\n\t\t\t\te.id = {};\n\t\t\t\te.name = \"{}\";\n\t\t\t\te.descr = \"{}\";\n\n\t\t\t\tserverErrs.Add(e.id, e);\n", errorID, errname, errdescr);
	sourcefileBody_ += "\t\t\t}\n\n";*/
	std::string tpl = R"delimiter(
		{{
            let e: ServerErr = new ServerErr();
            e.id = {};
            e.name = "{}";
            e.descr = "{}";
            ServerErrorDescrs.serverErrs.set(e.id, e);
        }}
)delimiter";
	sourcefileBody_ += fmt::format(tpl.c_str(), errorID, errname, errdescr);

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeServerErrorDescrsModuleEnd()
{
	/*sourcefileBody_ += "\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic void Clear()\n\t\t{\n\t\t\tserverErrs.Clear();\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic string serverErrStr(UInt16 id)\n\t\t{\n\t\t\tServerErr e;\n\t\t\tif(!serverErrs.TryGetValue(id, out e))\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn e.name + \"[\" + e.descr + \"]\";\n\t\t}\n\n";
	sourcefileBody_ += "\t\tpublic ServerErr serverErr(UInt16 id)\n\t\t{\n\t\t\tServerErr e;\n\t\t\tserverErrs.TryGetValue(id, out e);\n\t\t\treturn e;\n\t\t}\n\n";

	sourcefileBody_ += "\n\n\n\t}\n}";*/

	sourcefileBody_ += R"delimiter(
	}

	public Clear() {
		ServerErrorDescrs.serverErrs.clear();
	}

	public serverErrStr(id: number): string {
		let e: ServerErr | undefined = ServerErrorDescrs.serverErrs.get(id);
		if (!e) {
			return "";
		}

		return e.name + "[" + e.descr + "]";
	}

	public serverErr(id: number): ServerErr | undefined {
		let e: ServerErr | undefined = ServerErrorDescrs.serverErrs.get(id);
		return e;
	}
}
)delimiter";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEngineMessagesModuleBegin()
{
	initBody_ = "";
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	
	sourcefileBody_ += R"delimiter(
import KBEDebug from "./KBEDebug";
import { KBEngineApp ,MemoryStream , DataTypes } from "./KBEngine";


export class Message {
    public id: number = 0;
    public name: string;
    public msglen: number = -1;
    public argtypes: number[] = [];
    public argsType: number = 0;

    constructor(msgid: number, msgname: string, length: number, argstype: number, msgargtypes: number[]) {
        this.id = msgid;
        this.name = msgname;
        this.msglen = length;
        this.argsType = argstype;

        this.argtypes = msgargtypes;
        // Dbg.DEBUG_MSG(string.Format("Message::Message() : ({ 0 } / {1} / {2})!", 
        //		msgname, msgid, msglen));
    }

    public handleMessage(msgstream: MemoryStream) {
    }
}
)delimiter";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEngineMessagesModuleMessage(Network::ExposedMessageInfo& messageInfos, COMPONENT_TYPE componentType)
{
	sourcefileBody_ += fmt::format("\nexport class Message_{} extends Message {{\n", messageInfos.name);

	sourcefileBody_ += R"delimiter(
	constructor(msgid: number, msgname: string, length: number, argstype: number, msgargtypes: number[]) {
        super(msgid, msgname, length, argstype, msgargtypes);
    }

	public override handleMessage(msgstream: MemoryStream) {
)delimiter";


	/*sourcefileBody_ += fmt::format("\n\tpublic Message_{}(MessageID msgid, string msgname, Int16 length, sbyte argstype, List<Byte> msgargtypes):\n\t\t\tbase(msgid, msgname, length, argstype, msgargtypes)\n\t\t{{\n", messageInfos.name);
	sourcefileBody_ += "\n\t}\n\n";*/

	//sourcefileBody_ += "\t\tpublic override void handleMessage(MemoryStream msgstream)\n";
	//sourcefileBody_ += "\t\t{\n";

	if (messageInfos.argsTypes.size() == 0)
	{
		//initBody_ += fmt::format("\t\tMessages.messages[\"{}\"] = new Message_{}({}, \"{}\", {}, {}, ", 
		//	messageInfos.name, messageInfos.name, messageInfos.id, messageInfos.name, messageInfos.msgLen, (int)messageInfos.argsType);
		//initBody_ += "new List<Byte>());\n";

		initBody_ += fmt::format("\t\tMessages.messages[\"{}\"] = new Message_{}({}, \"{}\", {}, {}, []); \n",
			messageInfos.name, messageInfos.name, messageInfos.id, messageInfos.name, messageInfos.msgLen, (int)messageInfos.argsType);

		

		if (componentType == CLIENT_TYPE)
		{
			if (messageInfos.argsType < 0)
			{
				sourcefileBody_ += fmt::format("\t\tKBEngineApp.app!.{}(msgstream); \n", messageInfos.name);
			}
			else
			{
				sourcefileBody_ += fmt::format("\t\tKBEngineApp.app!.{}(); \n", messageInfos.name);
			}
		}
	}
	else
	{
		std::string argsparse = "";
		std::string giveargs = "";
		//initBody_ += fmt::format("\n\t\t\tList<Byte> {}_argstypes = new List<Byte>();\n", messageInfos.name);
		initBody_ += fmt::format("\n\t\tlet {}_argstypes: number[] = [];\n", messageInfos.name);

		for (int i = 0; i < (int)messageInfos.argsTypes.size(); ++i)
		{
			int argindex = (i + 1);
			std::string nativetype = datatype2nativetype(messageInfos.argsTypes[i]);

			KBE_ASSERT(nativetype != "FIXED_DICT" && nativetype != "ARRAY" && nativetype != "PYTHON" && nativetype != "ENTITYCALL");

			std::string readName = nativetype;
			std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
			readName[0] = std::toupper(readName[0]);

			argsparse += fmt::format("\t\tlet arg{} = msgstream.Read{}();\n", argindex, readName);
			giveargs += fmt::format("arg{}, ", argindex);
			initBody_ += fmt::format("\t\t{}_argstypes.push({});\n", messageInfos.name, (int)messageInfos.argsTypes[i]);
		}

		if (giveargs.size() > 0)
			giveargs.erase(giveargs.size() - 2, 2);

		/*initBody_ += fmt::format("\t\t\tMessages.messages[\"{}\"] = new Message_{}({}, \"{}\", {}, {}, {}_argstypes);\n", 
			messageInfos.name, messageInfos.name, messageInfos.id, messageInfos.name, messageInfos.msgLen, (int)messageInfos.argsType, messageInfos.name);
		*/

		initBody_ += fmt::format("\t\tMessages.messages[\"{}\"] = new Message_{}({}, \"{}\", {}, {}, {}_argstypes);\n",
			messageInfos.name, messageInfos.name, messageInfos.id, messageInfos.name, messageInfos.msgLen, (int)messageInfos.argsType, messageInfos.name);

		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += argsparse;
			sourcefileBody_ += fmt::format("\t\tKBEngineApp.app!.{}({});\n", messageInfos.name, giveargs);
		}
	}

	if (componentType == CLIENT_TYPE)
	{
		initBody_ += fmt::format("\t\tMessages.clientMessages[{}] = Messages.messages[\"{}\"];\n\n", messageInfos.id, messageInfos.name);
	}
	else if (componentType == LOGINAPP_TYPE)
	{
		initBody_ += fmt::format("\t\tMessages.loginappMessages[{}] = Messages.messages[\"{}\"];\n\n", messageInfos.id, messageInfos.name);
	}
	else if (componentType == BASEAPP_TYPE)
	{
		initBody_ += fmt::format("\t\tMessages.baseappMessages[{}] = Messages.messages[\"{}\"];\n\n", messageInfos.id, messageInfos.name);
	}

	sourcefileBody_ += "\t}\n";

	sourcefileBody_ += "}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEngineMessagesModuleEnd()
{
	sourcefileBody_ += R"delimiter(
export default class Messages {

    public static loginappMessages: { [key: string]: Message } = {};
    public static baseappMessages: { [key: string]: Message } = {};
    public static clientMessages: { [key: string]: Message } = {};
    public static messages: { [key: string]: Message } = {};

	static clear() {
        Messages.loginappMessages = {};
        Messages.baseappMessages = {};
        Messages.clientMessages = {};
        Messages.messages = {};

        Messages.BindFixedMessage();
    }

    static BindFixedMessage() {
)delimiter";

	sourcefileBody_ += initBody_;

	sourcefileBody_ += "\n\t\treturn true;";
	sourcefileBody_ += "\n\t}";
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
void ClientSDKTypeScript::onCreateEntityDefsModuleFileName()
{
	sourcefileName_ = "EntityDef.ts";
	//sourcefileName_ = "KBEngine.ts";
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleBegin()
{
	initBody_ = "";
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += R"delimiter(
import { DataTypes , KBETypes } from "./KBEngine";
import { ScriptModule } from "./ScriptModule";
import { Vector3, Vector2 ,Vector4} from "./KBEMath";
import { Property } from "./Property";
import { Method } from "./Method";

export default class EntityDef {
    public static datatype2id: Map<string, number> = new Map();
    public static datatypes: Map<string, DataTypes.DATATYPE_BASE> = new Map();
    public static id2datatypes: Map<number, DataTypes.DATATYPE_BASE> = new Map();
    public static entityclass: Map<string, number> = new Map();
    public static moduledefs: Map<string, ScriptModule> = new Map();
    public static idmoduledefs: Map<number, ScriptModule> = new Map();


    public static init() {
        this.initDataTypes();
        this.initDefTypes();
        this.initScriptModules();
        return true;
    }

    public static reset() {
        this.clear();
        return this.init();
    }

    public static clear() {
        this.datatype2id.clear();
        this.datatypes.clear();
        this.id2datatypes.clear();
        this.entityclass.clear();
        this.moduledefs.clear();
        this.idmoduledefs.clear();
    }


    
    public static initDataTypes() {
        EntityDef.datatypes.set("UINT8", new DataTypes.DATATYPE_UINT8());
		EntityDef.datatypes.set("UINT16", new DataTypes.DATATYPE_UINT16());
		EntityDef.datatypes.set("UINT32", new DataTypes.DATATYPE_UINT32());
		EntityDef.datatypes.set("UINT64", new DataTypes.DATATYPE_UINT64());
		EntityDef.datatypes.set("INT8", new DataTypes.DATATYPE_INT8());
		EntityDef.datatypes.set("INT16", new DataTypes.DATATYPE_INT16());
		EntityDef.datatypes.set("INT32", new DataTypes.DATATYPE_INT32());
		EntityDef.datatypes.set("INT64", new DataTypes.DATATYPE_INT64());
		EntityDef.datatypes.set("FLOAT", new DataTypes.DATATYPE_FLOAT());
		EntityDef.datatypes.set("DOUBLE", new DataTypes.DATATYPE_DOUBLE());
		EntityDef.datatypes.set("STRING", new DataTypes.DATATYPE_STRING());
		EntityDef.datatypes.set("VECTOR2", new DataTypes.DATATYPE_VECTOR2());
		EntityDef.datatypes.set("VECTOR3", new DataTypes.DATATYPE_VECTOR3());
		EntityDef.datatypes.set("VECTOR4", new DataTypes.DATATYPE_VECTOR4());
		EntityDef.datatypes.set("PYTHON", new DataTypes.DATATYPE_PYTHON());
		EntityDef.datatypes.set("UNICODE", new DataTypes.DATATYPE_UNICODE());
		EntityDef.datatypes.set("ENTITYCALL", new DataTypes.DATATYPE_ENTITYCALL());
		EntityDef.datatypes.set("BLOB", new DataTypes.DATATYPE_BLOB());
    }

)delimiter";

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleEnd()
{
	sourcefileBody_ += "\t}\n\n\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleInitScriptBegin()
{
	sourcefileBody_ += "\tpublic static  initScriptModules(){\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleInitScriptEnd()
{
	sourcefileBody_ += "\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleInitDefTypesBegin()
{
	sourcefileBody_ += "\tpublic static initDefTypes() {\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleInitDefTypesEnd()
{
	/*sourcefileBody_ += "\t\tforeach(string datatypeStr in EntityDef.datatypes.Keys)\n\t\t\t{\n";
	sourcefileBody_ += "\t\t\tDATATYPE_BASE dataType = EntityDef.datatypes[datatypeStr];\n";
	sourcefileBody_ += "\t\t\tif(dataType != null)\n\t\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\tdataType.bind();\n\t\t\t\t}\n\t\t\t}\n";*/

	sourcefileBody_ += R"delimiter(
		for (let datatypeStr of EntityDef.datatypes.keys()) {
            let dataType = EntityDef.datatypes.get(datatypeStr);
            if (dataType != null) {
                dataType.Bind();
            }
        }
)delimiter";

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleInitDefType(const DataType* pDataType)
{
	uint16 typeID = datatype2id(pDataType->getName());
	if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		typeID = pDataType->id();
		KBE_ASSERT(typeID > datatype2id("KBE_DATATYPE2ID_MAX"));
	}

	static std::map< int, std::string > type2name;

	sourcefileBody_ += fmt::format("\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\tlet utype = {};\n", typeID);

	std::string typeName = (strlen(pDataType->aliasName()) > 0 ? pDataType->aliasName() : fmt::format("AnonymousArray_{}", typeID));
	sourcefileBody_ += fmt::format("\t\t\tlet typeName = \"{}\";\n", typeName);

	std::map< int, std::string >::iterator iter = type2name.find(typeID);
	if(iter == type2name.end())
		type2name[typeID] = (strlen(pDataType->getName()) > 0 ? pDataType->getName() : typeName);

	if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
	{
		sourcefileBody_ += fmt::format("\t\t\tlet datatype = new KBETypes.DATATYPE_{}();\n",  typeName);
		sourcefileBody_ += fmt::format("\t\t\tEntityDef.datatypes.set(typeName, datatype);\n");
	}
	else if (strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		FixedArrayType* pFixedArrayType = const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pDataType));
		typeID = datatype2id(pFixedArrayType->getDataType()->getName());

		if (typeID == 0 || strcmp(pFixedArrayType->getDataType()->getName(), "FIXED_DICT") == 0 ||
			strcmp(pFixedArrayType->getDataType()->getName(), "ARRAY") == 0)
			typeID = pFixedArrayType->getDataType()->id();

		sourcefileBody_ += fmt::format("\t\t\tlet datatype = new KBETypes.DATATYPE_{}();\n", typeName);
		sourcefileBody_ += fmt::format("\t\t\tEntityDef.datatypes.set(typeName, datatype);\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\tlet name = \"{}\";\n", pDataType->getName());
		sourcefileBody_ += fmt::format("\t\t\tlet val = EntityDef.datatypes.get(name);\n");
		sourcefileBody_ += fmt::format("\t\t\tEntityDef.datatypes.set(typeName, val);\n");
	}

	sourcefileBody_ += fmt::format("\t\t\tEntityDef.id2datatypes[utype] = EntityDef.datatypes.get(typeName);\n");
	sourcefileBody_ += fmt::format("\t\t\tEntityDef.datatype2id[typeName] = utype;\n");
	sourcefileBody_ += fmt::format("\t\t}}\n\n");

	return true;
}

//-------------------------------------------------------------------------------------
void ClientSDKTypeScript::onEntityCallModuleFileName(const std::string& moduleName)
{
	sourcefileName_ = std::string("EntityCall") + moduleName + moduleSuffix + ".ts";
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityCallBegin(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", fmt::format("\t\n",
		sourcefileName_));

	sourcefileBody_ += "import { EntityCall,DataTypes,KBETypes } from './KBEngine';\n";
	sourcefileBody_ += "import EntityDef from './EntityDef';\n";
	//sourcefileBody_ += "import * as KBEngine from './KBEngine';\n";


	// 导入组件call
	if (!pScriptDefModule->isComponentModule())
	{
		std::set<std::string> uniqueComponentCallStrings;

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			EntityComponentType* pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();

			

			uniqueComponentCallStrings.insert(fmt::format("import {{ EntityBaseEntityCall_{}{} }} from './EntityCall{}{}';", pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix));
			uniqueComponentCallStrings.insert(fmt::format("import {{ EntityCellEntityCall_{}{} }} from './EntityCall{}{}';", pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix));
		}


		for (auto it = uniqueComponentCallStrings.begin(); it != uniqueComponentCallStrings.end(); ++it) {
			sourcefileBody_ += fmt::format("{}\n",*it);
		}

		
	}


	sourcefileBody_ += std::string("// defined in */scripts/entity_defs/") + pScriptDefModule->getName() + ".def\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityCallEnd(ScriptDefModule* pScriptDefModule)
{
	//sourcefileBody_ += fmt::format("\t}}\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityCallMethodBegin(ScriptDefModule* pScriptDefModule, MethodDescription* pMethodDescription, const char* fillString1, const char* fillString2, COMPONENT_TYPE componentType)
{
	sourcefileBody_ += fmt::format("\tpublic {}({}){{\n", pMethodDescription->getName(), fillString1);

	sourcefileBody_ += fmt::format("\t\tlet pBundle = this.NewCallToMethod(\"{}\", {});\n", pMethodDescription->getName(), (pScriptDefModule->isComponentModule() ? "this.entityComponentPropertyID" : "0"));
	sourcefileBody_ += fmt::format("\t\tif(pBundle == null)\n");
	sourcefileBody_ += fmt::format("\t\t\treturn;\n\n");

	std::vector<DataType*>& argTypes = pMethodDescription->getArgTypes();
	std::vector<DataType*>::iterator iter = argTypes.begin();

	std::string writeName;

	int i = 1;

	for (; iter != argTypes.end(); ++iter)
	{
		DataType* pDataType = (*iter);

		if (pDataType->type() == DATA_TYPE_FIXEDDICT)
		{
			writeName = fmt::format("(EntityDef.id2datatypes[{}] as KBETypes.DATATYPE_{}).addToStreamEx(this.bundle!, arg{})",
				pDataType->id(),pDataType->aliasName(), i);
		}
		else if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
		{
			if (strlen(pDataType->aliasName()) > 0)
			{
				writeName = fmt::format("(EntityDef.id2datatypes[{}] as KBETypes.DATATYPE_{}).addToStreamEx(this.bundle!, arg{})",
					pDataType->id(), pDataType->aliasName(),  i);
			}
			else
			{
				writeName = fmt::format("(EntityDef.id2datatypes[{}] as KBETypes.DATATYPE_AnonymousArray_{}).addToStreamEx(this.bundle!, arg{})",
					pDataType->id(), pDataType->id(),  i);
			}
		}
		else
		{
			writeName = datatype2nativetype(pDataType->getName());
			std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
			writeName[0] = std::toupper(writeName[0]);

			

			if (writeName == "Uint64") {
				//writeName = fmt::format("stream.Write{}(DataTypes.KB_UINT64.fromBigInt(v[i]))", writeName);
				writeName = fmt::format("this.bundle!.Write{}(DataTypes.KB_UINT64.fromBigInt(arg{}))", writeName, i);
			}
			else if (writeName == "Int64") {
				//writeName = fmt::format("stream.Write{}(DataTypes.KB_INT64.fromBigInt(v[i]))", writeName);
				writeName = fmt::format("this.bundle!.Write{}(DataTypes.KB_INT64.fromBigInt(arg{}))", writeName, i);
			}
			else {
				writeName = fmt::format("this.bundle!.Write{}(arg{})", writeName, i);
			}
		}

		sourcefileBody_ += fmt::format("\t\t{};\n", writeName);

		i++;
	}

	sourcefileBody_ += fmt::format("\t\tthis.SendCall();\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityCallMethodEnd(ScriptDefModule* pScriptDefModule, MethodDescription* pMethodDescription)
{
	sourcefileBody_ += fmt::format("\t}}\n\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeBaseEntityCallBegin(ScriptDefModule* pScriptDefModule)
{
	std::string newModuleName;

	newModuleName = std::string("EntityBaseEntityCall_") + std::string(pScriptDefModule->getName()) + moduleSuffix;
	sourcefileBody_ += fmt::format("export class {} extends EntityCall {{\n", newModuleName);

	if (!pScriptDefModule->isComponentModule())
	{
		std::string initstr = "";

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();

			sourcefileBody_ += fmt::format("\tpublic {}: EntityBaseEntityCall_{}{};\n",
				pPropertyDescription->getName(),pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix);

			initstr += fmt::format("\t\tthis.{} = new EntityBaseEntityCall_{}{}({}, this.id);\n",
				pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pPropertyDescription->getUType());
		}

		sourcefileBody_ += fmt::format("\n\tconstructor(eid: number, ename: string) {{\n");
		sourcefileBody_ += fmt::format("\t\tsuper(eid, ename);\n");
		sourcefileBody_ += initstr;
	}
	else
	{
		sourcefileBody_ += fmt::format("\tpublic entityComponentPropertyID:number = 0;\n");

		sourcefileBody_ += fmt::format("\n\tconstructor(ecpID: number, eid: number) {{ \n\t\tsuper(eid, \"{}\");\n", pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\tthis.entityComponentPropertyID = ecpID;\n");
	}

	sourcefileBody_ += fmt::format("\t\tthis.entityCallType = 1;\n");
	sourcefileBody_ += fmt::format("\t}}\n\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeBaseEntityCallEnd(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ += fmt::format("}}\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeCellEntityCallBegin(ScriptDefModule* pScriptDefModule)
{
	std::string newModuleName;

	newModuleName = std::string("EntityCellEntityCall_") + std::string(pScriptDefModule->getName()) + moduleSuffix;
	sourcefileBody_ += fmt::format("export class {} extends EntityCall{{\n", newModuleName);

	if (!pScriptDefModule->isComponentModule())
	{
		std::string initstr = "";

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			EntityComponentType* pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();

			sourcefileBody_ += fmt::format("\tpublic {}:EntityCellEntityCall_{}{};\n",
				pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix);

			initstr += fmt::format("\t\tthis.{} = new EntityCellEntityCall_{}{}({}, this.id);\n",
				pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pPropertyDescription->getUType());
		}

		sourcefileBody_ += fmt::format("\n\tconstructor(eid: number, ename: string) {{ \n\t\tsuper(eid, ename);\n", newModuleName);
		sourcefileBody_ += initstr;
	}
	else
	{
		sourcefileBody_ += fmt::format("\tpublic entityComponentPropertyID:number = 0;\n");

		sourcefileBody_ += fmt::format("\n\tconstructor(ecpID: number, eid: number) {{ \n\t\tsuper(eid, \"{}\");\n", newModuleName, pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\tthis.entityComponentPropertyID = ecpID;\n");
		sourcefileBody_ += fmt::format("\t\tthis.className = \"{}\";\n", pScriptDefModule->getName());
	}

	sourcefileBody_ += fmt::format("\t\tthis.entityCallType = 0;\n");
	sourcefileBody_ += fmt::format("\t}}\n\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeCellEntityCallEnd(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ += fmt::format("}}\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeCustomDataTypesBegin()
{
	/*initBody_ = "";
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");*/

//	sourcefileBody_ +=  R"delimiter(
//import * as DataTypes from "./DataTypes";
//import MemoryStream from "./MemoryStream";
//import Bundle from "./Bundle";
//
//)delimiter";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeCustomDataTypesEnd()
{
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::createArrayChildClass(DataType* pRootDataType, DataType* pDataType, const std::string& className, const std::string& tabs, int numLayer)
{
	sourcefileBody_ += fmt::format("export class DATATYPE_{} extends DataTypes.DATATYPE_BASE{{\n",  className);

	uint16 typeID = datatype2id(pDataType->getName());
	if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		typeID = pDataType->id();
		KBE_ASSERT(typeID > datatype2id("KBE_DATATYPE2ID_MAX"));
	}

	std::string readName;
	std::string typeName = (strlen(pDataType->aliasName()) > 0 ? pDataType->aliasName() : fmt::format("AnonymousArray_{}", typeID));

	bool isFixedType = strcmp(pDataType->getName(), "FIXED_DICT") == 0 ||
		strcmp(pDataType->getName(), "ARRAY") == 0;

	if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
	{
		readName = fmt::format("this.itemType.createFromStreamEx(stream)");

		sourcefileBody_ += fmt::format("\tprivate itemType = new DATATYPE_{}();\n\n", pDataType->aliasName());

		// 如果是非匿名的数组，则第一层解析应该直接设置为有名字的类别
		// 否则设置为系统List类别
		if (numLayer == 1)
		{
			if (strlen(pRootDataType->aliasName()) == 0 || pRootDataType->aliasName()[0] == '_')
			{
				typeName = fmt::format("Array<{}>", typeName);
			}
			else
			{
				typeName = pRootDataType->aliasName();
			}
		}
		else
		{
			typeName = fmt::format("Array<{}>", typeName);
		}

		sourcefileBody_ += fmt::format("\tpublic  createFromStreamEx(stream:MemoryStream ) : {}{{\n", typeName );
		sourcefileBody_ += fmt::format("\t\tlet size = stream.ReadUint32();\n");
		sourcefileBody_ += fmt::format("\t\tlet datas = new {}();\n\n", typeName);
		sourcefileBody_ += fmt::format("\t\twhile(size > 0)\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t--size;\n");
		sourcefileBody_ += fmt::format("\t\t\tdatas.push({});\n", readName);
		sourcefileBody_ += fmt::format("\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\treturn datas;\n");
		sourcefileBody_ += fmt::format("\t}}\n\n");


		sourcefileBody_ += fmt::format("\tpublic addToStreamEx(stream:Bundle, v:{} ){{\n", typeName);
		sourcefileBody_ += fmt::format("\t\tstream.WriteUint32(v.length >>> 0);\n");
		sourcefileBody_ += fmt::format("\t\tfor(let i=0; i<v.length; ++i)\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");

		std::string writeName;
		if (isFixedType)
		{
			writeName = fmt::format("this.itemType.addToStreamEx(stream, v[i])");
		}
		else
		{
			writeName = datatype2nativetype(pDataType->getName());
			std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
			writeName[0] = std::toupper(writeName[0]);
			//writeName = fmt::format("stream.Write{}(v[i])", writeName);

			if (writeName == "Uint64") {
				writeName = fmt::format("stream.Write{}(DataTypes.KB_UINT64.fromBigInt(v[i]))", writeName);
			}
			else if (writeName == "Int64") {
				writeName = fmt::format("stream.Write{}(DataTypes.KB_INT64.fromBigInt(v[i]))", writeName);
			}
			else {
				writeName = fmt::format("stream.Write{}(v[i])", writeName);
			}
		}

		sourcefileBody_ += fmt::format("\t\t\t{};\n", writeName);
		sourcefileBody_ += fmt::format("\t\t}}\n");
		sourcefileBody_ += fmt::format("\t}}\n");
		sourcefileBody_ += fmt::format("}}\n\n");
	}
	else if (strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

		std::string classNameStr = typeName;

		// 如果是非匿名的数组，则第一层解析应该直接设置为有名字的类别
		// 否则设置为系统List类别
		if (numLayer == 1)
		{
			if (strlen(pRootDataType->aliasName()) == 0 || pRootDataType->aliasName()[0] == '_')
			{
				typeName = "";
				getArrayType(pFixedArrayType, typeName);
				typeName = fmt::format("Array<{}>", typeName);
			}
			else
			{
				typeName = pRootDataType->aliasName();
			}
		}
		else
		{
			typeName = "";
			getArrayType(pFixedArrayType, typeName);
			typeName = fmt::format("Array<{}>", typeName);
		}

		readName = fmt::format("this.itemType.createFromStreamEx(stream)");

		std::string childClassName = classNameStr + "_ChildArray";
		sourcefileBody_ += fmt::format("\tprivate  itemType:DATATYPE_{} = new DATATYPE_{}();\n\n", childClassName, childClassName);

		

		sourcefileBody_ += fmt::format("\tpublic  createFromStreamEx(stream:MemoryStream ) : {}{{\n", typeName);
		sourcefileBody_ += fmt::format("\t\tlet size = stream.ReadUint32();\n");
		sourcefileBody_ += fmt::format("\t\tlet datas = new {}();\n\n", typeName);
		sourcefileBody_ += fmt::format("\t\twhile(size > 0)\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t--size;\n");
		sourcefileBody_ += fmt::format("\t\t\tdatas.push({});\n", readName);
		sourcefileBody_ += fmt::format("\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\treturn datas;\n");
		sourcefileBody_ += fmt::format("\t}}\n\n");


		sourcefileBody_ += fmt::format("\tpublic addToStreamEx(stream:Bundle ,v:{} ){{\n", typeName);
		sourcefileBody_ += fmt::format("\t\tstream.WriteUint32(v.length >>> 0);\n");
		sourcefileBody_ += fmt::format("\t\tfor(let i=0; i<v.length; ++i)\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");

		std::string writeName;
		if (isFixedType)
		{
			writeName = fmt::format("this.itemType.addToStreamEx(stream, v[i])", writeName);
		}
		else
		{
			writeName = datatype2nativetype(pDataType->getName());
			std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
			writeName[0] = std::toupper(writeName[0]);
			//writeName = fmt::format("stream.Write{}(v[i])", writeName);

			if (writeName == "Uint64") {
				writeName = fmt::format("stream.Write{}(DataTypes.KB_UINT64.fromBigInt(v[i]))", writeName);
			}
			else if (writeName == "Int64") {
				writeName = fmt::format("stream.Write{}(DataTypes.KB_INT64.fromBigInt(v[i]))", writeName);
			}
			else {
				writeName = fmt::format("stream.Write{}(v[i])", writeName);
			}
		}

		sourcefileBody_ += fmt::format("\t\t\t{};\n", writeName);
		sourcefileBody_ += fmt::format("\t\t}}\n");
		sourcefileBody_ += fmt::format("\t}}\n");
		sourcefileBody_ += fmt::format("}}\n\n");


		if (!createArrayChildClass(pRootDataType, pFixedArrayType->getDataType(), childClassName, tabs, numLayer + 1))
			return false;
	}
	else
	{
		readName = datatype2nativetype(pDataType->getName());
		typeName = typeToType(readName);
		std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
		readName[0] = std::toupper(readName[0]);
		

		if (readName == "Uint64" || readName == "Int64") {
			readName = fmt::format("stream.Read{}().toBigInt()", readName);
		}
		else {
			readName = fmt::format("stream.Read{}()", readName);
		}

		sourcefileBody_ += fmt::format("\tpublic  createFromStreamEx(stream:MemoryStream ) : Array<{}>{{\n", typeName);
		sourcefileBody_ += fmt::format("\t\tlet size = stream.ReadUint32();\n");
		sourcefileBody_ += fmt::format("\t\tlet datas = new Array<{}>();\n\n", typeName, typeName);
		sourcefileBody_ += fmt::format("\t\twhile(size > 0)\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t--size;\n");
		sourcefileBody_ += fmt::format("\t\t\tdatas.push({});\n", readName);
		sourcefileBody_ += fmt::format("\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\treturn datas;\n");
		sourcefileBody_ += fmt::format("\t}}\n\n");

		sourcefileBody_ += fmt::format("\tpublic addToStreamEx(stream:Bundle, v:Array<{}> ){{\n", typeName);
		sourcefileBody_ += fmt::format("\t\tstream.WriteUint32(v.length >>> 0);\n");
		sourcefileBody_ += fmt::format("\t\tfor(let i=0; i<v.length; ++i)\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");

		std::string writeName;
		writeName = datatype2nativetype(pDataType->getName());
		std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
		writeName[0] = std::toupper(writeName[0]);
		

		if (writeName == "Uint64") {
			writeName = fmt::format("stream.Write{}(DataTypes.KB_UINT64.fromBigInt(v[i]))", writeName);
		}
		else if (writeName == "Int64") {
			writeName = fmt::format("stream.Write{}(DataTypes.KB_INT64.fromBigInt(v[i]))", writeName);
		}
		else {
			writeName = fmt::format("stream.Write{}(v[i])", writeName);
		}

		sourcefileBody_ += fmt::format("\t\t\t{};\n", writeName);
		sourcefileBody_ += fmt::format("\t\t}}\n");
		sourcefileBody_ += fmt::format("\t}}\n");
		sourcefileBody_ += fmt::format("}}\n\n");
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeCustomDataType(const DataType* pDataType)
{
	uint16 typeID = datatype2id(pDataType->getName());
	if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		typeID = pDataType->id();
		KBE_ASSERT(typeID > datatype2id("KBE_DATATYPE2ID_MAX"));
	}

	static std::map< int, std::string > type2name;

	std::string typeName = (strlen(pDataType->aliasName()) > 0 ? pDataType->aliasName() : fmt::format("AnonymousArray_{}", typeID));

	std::map< int, std::string >::iterator iter = type2name.find(typeID);
	if (iter == type2name.end())
		type2name[typeID] = (strlen(pDataType->getName()) > 0 ? pDataType->getName() : typeName);

	if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
	{
		sourcefileBody_ += fmt::format("\n\nexport class DATATYPE_{} extends DataTypes.DATATYPE_BASE {{\n", typeName);
		std::map<std::string, std::string> allClassName;

		FixedDictType* dictdatatype = const_cast<FixedDictType*>(static_cast<const FixedDictType*>(pDataType));

		// 先创建属性
		{
			FixedDictType::FIXEDDICT_KEYTYPE_MAP& keys = dictdatatype->getKeyTypes();
			FixedDictType::FIXEDDICT_KEYTYPE_MAP::const_iterator keyiter = keys.begin();
			for (; keyiter != keys.end(); ++keyiter)
			{
				DataType* pKeyDataType = keyiter->second->dataType;
				if (strcmp(pKeyDataType->getName(), "FIXED_DICT") == 0)
				{
					sourcefileBody_ += fmt::format("\tpublic {}_DataType:DATATYPE_{} = new DATATYPE_{}();\n",
						keyiter->first, pKeyDataType->aliasName(), pKeyDataType->aliasName());
				}
				else if (strcmp(pKeyDataType->getName(), "ARRAY") == 0)
				{
					FixedArrayType* pFixedArrayType = const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pKeyDataType));

					std::string className = pKeyDataType->aliasName();

					if (strlen(pFixedArrayType->aliasName()) == 0 || pFixedArrayType->aliasName()[0] == '_')
					{
						sourcefileBody_ += fmt::format("\tpublic {}_DataType:DATATYPE_{} = new DATATYPE_{}();\n\n",
							 keyiter->first, className + "_ChildArray", className + "_ChildArray");

						/*std::map<std::string, std::string>::iterator findChildClassNameIter = allClassName.find(className + "_ChildArray");

						if (findChildClassNameIter == allClassName.end())
						{
							allClassName[className + "_ChildArray"] = typeName;
							createArrayChildClass(pFixedArrayType, pFixedArrayType->getDataType(), className + "_ChildArray", "\t\t");
						}*/
					}
					else
					{
						sourcefileBody_ += fmt::format("\tpublic {}_DataType:DATATYPE_{} = new DATATYPE_{}();\n\n",
							 keyiter->first, className, className);
					}
				}
				else
				{
				}
			}
		}

		// 创建createFromStreamEx方法
		{
			sourcefileBody_ += fmt::format("\tpublic createFromStreamEx(stream: MemoryStream) : {} {{\n", typeName);

			sourcefileBody_ += fmt::format("\t\tlet datas = new {}();\n",  typeName);

			FixedDictType::FIXEDDICT_KEYTYPE_MAP& keys = dictdatatype->getKeyTypes();
			FixedDictType::FIXEDDICT_KEYTYPE_MAP::const_iterator keyiter = keys.begin();
			for (; keyiter != keys.end(); ++keyiter)
			{
				DataType* pKeyDataType = keyiter->second->dataType;
				if (strcmp(pKeyDataType->getName(), "FIXED_DICT") == 0)
				{
					sourcefileBody_ += fmt::format("\t\tdatas.{} = this.{}_DataType.createFromStreamEx(stream);\n", keyiter->first, keyiter->first);
				}
				else if (strcmp(pKeyDataType->getName(), "ARRAY") == 0)
				{
					sourcefileBody_ += fmt::format("\t\tdatas.{} = this.{}_DataType.createFromStreamEx(stream);\n", keyiter->first, keyiter->first);
				}
				else
				{
					std::string readName = datatype2nativetype(pKeyDataType->getName());
					std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
					readName[0] = std::toupper(readName[0]);

					if (readName == "Uint64" || readName == "Int64") {
						readName = fmt::format("stream.Read{}().toBigInt()", readName);
						sourcefileBody_ += fmt::format("\t\tdatas.{} = {};\n", keyiter->first, readName);
					}
					else {
						readName = fmt::format("stream.Read{}()", readName);
						sourcefileBody_ += fmt::format("\t\tdatas.{} = {};\n", keyiter->first, readName);
					}
					
				}
			}

			sourcefileBody_ += fmt::format("\t\treturn datas;\n");
			sourcefileBody_ += fmt::format("\t}}\n\n");
		}

		// 创建addToStreamEx方法
		{
			sourcefileBody_ += fmt::format("\tpublic addToStreamEx(stream:Bundle,  v:{}){{\n", typeName);

			FixedDictType::FIXEDDICT_KEYTYPE_MAP& keys = dictdatatype->getKeyTypes();
			FixedDictType::FIXEDDICT_KEYTYPE_MAP::const_iterator keyiter = keys.begin();
			for (; keyiter != keys.end(); ++keyiter)
			{
				DataType* pKeyDataType = keyiter->second->dataType;
				if (strcmp(pKeyDataType->getName(), "FIXED_DICT") == 0)
				{
					sourcefileBody_ += fmt::format("\t\tthis.{}_DataType.addToStreamEx(stream, v.{});\n", keyiter->first, keyiter->first);
				}
				else if (strcmp(pKeyDataType->getName(), "ARRAY") == 0)
				{
					sourcefileBody_ += fmt::format("\t\tthis.{}_DataType.addToStreamEx(stream, v.{});\n", keyiter->first, keyiter->first);
				}
				else
				{
					std::string writeName = datatype2nativetype(pKeyDataType->getName());
					std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
					writeName[0] = std::toupper(writeName[0]);

					if (writeName == "Uint64" ) {
						sourcefileBody_ += fmt::format("\t\tstream.Write{}(DataTypes.KB_UINT64.fromBigInt(v.{}));\n", writeName, keyiter->first);
					}else if ( writeName == "Int64") {
						sourcefileBody_ += fmt::format("\t\tstream.Write{}(DataTypes.KB_INT64.fromBigInt(v.{}));\n", writeName, keyiter->first);
					}
					else {
						sourcefileBody_ += fmt::format("\t\tstream.Write{}(v.{});\n", writeName, keyiter->first);
					}

				}
			}

			sourcefileBody_ += fmt::format("\t}}\n");
		}

		sourcefileBody_ += fmt::format("}}\n\n");



		// 创建子类属性
		{
			FixedDictType::FIXEDDICT_KEYTYPE_MAP& keys = dictdatatype->getKeyTypes();
			FixedDictType::FIXEDDICT_KEYTYPE_MAP::const_iterator keyiter = keys.begin();
			for (; keyiter != keys.end(); ++keyiter)
			{
				DataType* pKeyDataType = keyiter->second->dataType;
				if (strcmp(pKeyDataType->getName(), "ARRAY") == 0)
				{
					FixedArrayType* pFixedArrayType = const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pKeyDataType));

					std::string className = pKeyDataType->aliasName();

					if (strlen(pFixedArrayType->aliasName()) == 0 || pFixedArrayType->aliasName()[0] == '_')
					{
						std::map<std::string, std::string>::iterator findChildClassNameIter = allClassName.find(className + "_ChildArray");

						if (findChildClassNameIter == allClassName.end())
						{
							allClassName[className + "_ChildArray"] = typeName;
							createArrayChildClass(pFixedArrayType, pFixedArrayType->getDataType(), className + "_ChildArray", "");
						}
					}
				}
			}
		}

	}
	else if (strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		FixedArrayType* pFixedArrayType = const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pDataType));
		typeID = datatype2id(pFixedArrayType->getDataType()->getName());

		if (typeID == 0 || strcmp(pFixedArrayType->getDataType()->getName(), "FIXED_DICT") == 0 ||
			strcmp(pFixedArrayType->getDataType()->getName(), "ARRAY") == 0)
			typeID = pFixedArrayType->getDataType()->id();

		std::string itemTypeName = typeToType(type2name[typeID]);
		if (itemTypeName == "")
		{
			itemTypeName = pFixedArrayType->getDataType()->aliasName();
		}

		std::string className = typeName;

		if (strlen(pFixedArrayType->aliasName()) == 0 || pFixedArrayType->aliasName()[0] == '_')
		{
			typeName = "";
			getArrayType(pFixedArrayType, typeName);
		}

		std::string readName;
		sourcefileBody_ += fmt::format("\n\nexport class DATATYPE_{} extends DataTypes.DATATYPE_BASE{{\n", className);

		bool isFixedType = strcmp(pFixedArrayType->getDataType()->getName(), "FIXED_DICT") == 0 ||
		strcmp(pFixedArrayType->getDataType()->getName(), "ARRAY") == 0;

		if (strcmp(pFixedArrayType->getDataType()->getName(), "FIXED_DICT") == 0)
		{
			readName = fmt::format("itemType.createFromStreamEx(stream)", readName);

			sourcefileBody_ += fmt::format("\tprivate  itemType:DATATYPE_{} = new DATATYPE_{}();\n\n",
			pFixedArrayType->getDataType()->aliasName(), pFixedArrayType->getDataType()->aliasName());

			sourcefileBody_ += fmt::format("\tpublic  createFromStreamEx(stream:MemoryStream):{}{{\n", typeName);
			sourcefileBody_ += fmt::format("\t\tlet size = stream.ReadUint32();\n");
			sourcefileBody_ += fmt::format("\t\tlet datas = new {}();\n\n", typeName);
			sourcefileBody_ += fmt::format("\t\twhile(size > 0)\n");
			sourcefileBody_ += fmt::format("\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t--size;\n");
			sourcefileBody_ += fmt::format("\t\t\tdatas.push(this.{});\n", readName);
			sourcefileBody_ += fmt::format("\t\t}}\n\n");
			sourcefileBody_ += fmt::format("\t\treturn datas;\n");
			sourcefileBody_ += fmt::format("\t}}\n\n");

			sourcefileBody_ += fmt::format("\tpublic addToStreamEx(stream:Bundle, v:{}){{\n", typeName);
			sourcefileBody_ += fmt::format("\t\tstream.WriteUint32(v.length >>> 0 );\n");
			sourcefileBody_ += fmt::format("\t\tfor(let i=0; i< v.length; ++i)\n");
			sourcefileBody_ += fmt::format("\t\t{{\n");

			std::string writeName;
			if (isFixedType)
			{
				writeName = fmt::format("this.itemType.addToStreamEx(stream, v[i])", writeName);
			}
			else
			{
				writeName = datatype2nativetype(pFixedArrayType->getDataType()->getName());
				std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
				writeName[0] = std::toupper(writeName[0]);

				if (writeName == "Uint64") {
					writeName = fmt::format("stream.Write{}(DataTypes.KB_UINT64.fromBigInt(v[i]))", writeName);
				}
				else if (writeName == "Int64") {
					writeName = fmt::format("stream.Write{}(DataTypes.KB_INT64.fromBigInt(v[i]))", writeName);
				}
				else {
					writeName = fmt::format("stream.Write{}(v[i])", writeName);
				}
				
			}

			sourcefileBody_ += fmt::format("\t\t\t{};\n", writeName);
			sourcefileBody_ += fmt::format("\t\t}}\n");
			sourcefileBody_ += fmt::format("\t}}\n");

			sourcefileBody_ += fmt::format("}}\n\n");
		}
		else if (strcmp(pFixedArrayType->getDataType()->getName(), "ARRAY") == 0)
		{
			readName = fmt::format("itemType.createFromStreamEx(stream){{", readName);

			sourcefileBody_ += fmt::format("\tprivate DATATYPE_{} itemType = new DATATYPE_{}();\n\n",
				className + "_ChildArray", className + "_ChildArray");

			createArrayChildClass(pFixedArrayType, pFixedArrayType->getDataType(), className + "_ChildArray", "\t\t");

			sourcefileBody_ += fmt::format("\tpublic {} createFromStreamEx(MemoryStream stream){{\n", typeName);
			sourcefileBody_ += fmt::format("\t\treturn {};\n", readName);
			sourcefileBody_ += fmt::format("\t}}\n\n");

			sourcefileBody_ += fmt::format("\tpublic void addToStreamEx(Bundle stream, {} v) {{\n", typeName);
			std::string writeName = fmt::format("itemType.addToStreamEx(stream, v)", writeName);
			sourcefileBody_ += fmt::format("\t\t{};\n", writeName);
			sourcefileBody_ += fmt::format("\t}}\n");

			sourcefileBody_ += fmt::format("}}\n\n");
		}
		else
		{
			readName = datatype2nativetype(pFixedArrayType->getDataType()->getName());
			std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
			readName[0] = std::toupper(readName[0]);
			readName = fmt::format("stream.Read{}()", readName);

			sourcefileBody_ += fmt::format("\tpublic createFromStreamEx(stream:MemoryStream): {}{{\n", typeName);
			sourcefileBody_ += fmt::format("\t\tlet size = stream.ReadUint32();\n");
			sourcefileBody_ += fmt::format("\t\tlet datas = new {}();\n\n",  typeName);
			sourcefileBody_ += fmt::format("\t\twhile(size > 0)\n");
			sourcefileBody_ += fmt::format("\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t--size;\n");
			sourcefileBody_ += fmt::format("\t\t\tdatas.push({});\n", readName);
			sourcefileBody_ += fmt::format("\t\t}}\n\n");
			sourcefileBody_ += fmt::format("\t\treturn datas;\n");
			sourcefileBody_ += fmt::format("\t}}\n\n");

			sourcefileBody_ += fmt::format("\tpublic addToStreamEx(stream:Bundle, v:{}){{\n", typeName);
			sourcefileBody_ += fmt::format("\t\tstream.WriteUint32( v.length >>> 0 );\n");
			sourcefileBody_ += fmt::format("\t\tfor(let i=0; i< v.length; ++i){{\n");

			std::string writeName;
			if (isFixedType)
			{
				writeName = fmt::format("itemType.addToStreamEx(stream, v[i])", writeName);
			}
			else
			{
				writeName = datatype2nativetype(pFixedArrayType->getDataType()->getName());
				std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
				writeName[0] = std::toupper(writeName[0]);
				writeName = fmt::format("stream.Write{}(v[i])", writeName);
			}

			sourcefileBody_ += fmt::format("\t\t\t{};\n", writeName);
			sourcefileBody_ += fmt::format("\t\t}}\n");
			sourcefileBody_ += fmt::format("\t}}\n");

			sourcefileBody_ += fmt::format("}}\n\n");
		}
	}
	else
	{
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleInitScript_ScriptModule(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ += fmt::format("\t\tlet p{}Module = new ScriptModule(\"{}\");\n", pScriptDefModule->getName(), pScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\tEntityDef.moduledefs[\"{}\"] = p{}Module;\n", pScriptDefModule->getName(), pScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\tEntityDef.idmoduledefs[{}] = p{}Module;\n\n", pScriptDefModule->getUType(), pScriptDefModule->getName());
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleInitScript_MethodDescr(ScriptDefModule* pScriptDefModule, MethodDescription* pDescr, COMPONENT_TYPE componentType)
{
	// 如果pDescr为None，并且是客户端方法，那么需要强制设定useMethodDescrAlias为true，否则默认为false将会出现问题
	if (!pDescr && componentType == CLIENT_TYPE)
	{
		sourcefileBody_ += fmt::format("\t\tp{}Module.useMethodDescrAlias = true;\n", pScriptDefModule->getName());
		return true;
	}

	assert(pDescr);

	sourcefileBody_ += fmt::format("\t\tlet p{}_{}_args = new Array<DataTypes.DATATYPE_BASE>();\n", pScriptDefModule->getName(), pDescr->getName());

	const std::vector<DataType*>& args = pDescr->getArgTypes();
	std::vector<DataType*>::const_iterator argiter = args.begin();
	for (; argiter != args.end(); ++argiter)
	{
		uint16 typeID = datatype2id((*argiter)->getName());
		if (typeID == 0 || strcmp((*argiter)->getName(), "FIXED_DICT") == 0 || strcmp((*argiter)->getName(), "ARRAY") == 0)
			typeID = (*argiter)->id();

		sourcefileBody_ += fmt::format("\t\tp{}_{}_args.push(EntityDef.id2datatypes[{}]);\n", pScriptDefModule->getName(), pDescr->getName(), typeID);
	}

	sourcefileBody_ += fmt::format("\n\t\tlet p{}_{} = new Method();\n", pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\tp{}_{}.name = \"{}\";\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\tp{}_{}.methodUtype = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());
	sourcefileBody_ += fmt::format("\t\tp{}_{}.aliasID = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->aliasID());
	sourcefileBody_ += fmt::format("\t\tp{}_{}.args = p{}_{}_args;\n\n", pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	sourcefileBody_ += fmt::format("\t\tp{}Module.methods[\"{}\"] = p{}_{}; \n",
		pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	if (pDescr->aliasID() != -1)
	{
		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\tp{}Module.useMethodDescrAlias = true;\n", pScriptDefModule->getName());
			sourcefileBody_ += fmt::format("\t\tp{}Module.idmethods[DataTypes.NumberUtil.toUInt16(p{}_{}.aliasID)] = p{}_{}; // 可能需要转(UInt16)\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
		else
		{
			KBE_ASSERT(false);
		}
	}
	else
	{
		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\tp{}Module.useMethodDescrAlias = false;\n", pScriptDefModule->getName());
			sourcefileBody_ += fmt::format("\t\tp{}Module.idmethods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		} 
		if (componentType == BASEAPP_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\tp{}Module.baseMethods[\"{}\"] = p{}_{};\n\n",
				pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

			sourcefileBody_ += fmt::format("\t\tp{}Module.idbaseMethods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
		else
		{
			sourcefileBody_ += fmt::format("\t\tp{}Module.cellMethods[\"{}\"] = p{}_{};\n\n",
				pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

			sourcefileBody_ += fmt::format("\t\tp{}Module.idcellMethods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
	}

	sourcefileBody_ += fmt::format("\t\t//Dbg.DEBUG_MSG(\"EntityDef::initScriptModules: add({}), method({} / {}).\");\n\n",
		pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityDefsModuleInitScript_PropertyDescr(ScriptDefModule* pScriptDefModule, PropertyDescription* pDescr)
{
	uint16 typeID = datatype2id(pDescr->getDataType()->getName());
	bool isFixedType = strcmp(pDescr->getDataType()->getName(), "FIXED_DICT") == 0 || strcmp(pDescr->getDataType()->getName(), "ARRAY") == 0;

	if (typeID == 0 || isFixedType)
		typeID = pDescr->getDataType()->id();

	sourcefileBody_ += fmt::format("\t\tlet p{}_{} = new Property();\n", pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\tp{}_{}.name = \"{}\";\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\tp{}_{}.properUtype = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());
	sourcefileBody_ += fmt::format("\t\tp{}_{}.properFlags = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getFlags());
	sourcefileBody_ += fmt::format("\t\tp{}_{}.aliasID = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->aliasID());

	if (isFixedType)
	{
		sourcefileBody_ += fmt::format("\t\tp{}_{}.defaultValStr = EntityDef.id2datatypes[{}].ParseDefaultValueString(\"{}\");\n",
			pScriptDefModule->getName(), pDescr->getName(), typeID, pDescr->getDefaultValStr());
	}
	else
	{
		std::string readName = typeToType(datatype2nativetype(typeID));

		if (readName == "Vector2" || readName == "Vector3" || readName == "Vector4")
		{
			sourcefileBody_ += fmt::format("\t\tlet {}_{}_defval = new {}();\n", pScriptDefModule->getName(),
				pDescr->getName(), readName);
		}
		else if (readName == "string")
		{
			sourcefileBody_ += fmt::format("\t\tlet {}_{}_defval = \"\";\n",  pScriptDefModule->getName(),
				pDescr->getName());
		}
		else if (readName == "PYTHON" || readName == "PY_DICT" || readName == "PY_TUPLE" || readName == "PY_LIST" || readName == "byte[]")
		{
			sourcefileBody_ += fmt::format("\t\tlet {}_{}_defval = new number[0];\n", pScriptDefModule->getName(),
				pDescr->getName());
		}
		else if (pDescr->getDataType()->type() == DATA_TYPE_ENTITY_COMPONENT)
		{
		}
		else if (readName == "bigint" )
		{
			sourcefileBody_ += fmt::format("\t\tlet {}_{}_defval:{} = BigInt(\"{}\");\n", pScriptDefModule->getName(),
				pDescr->getName(), readName, pDescr->getDefaultValStr());
		}
		else
		{
			sourcefileBody_ += fmt::format("\t\tlet {}_{}_defval:{} = Number(\"{}\");\n",pScriptDefModule->getName(),
				pDescr->getName(), readName, pDescr->getDefaultValStr());
		}

		if (pDescr->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
			sourcefileBody_ += fmt::format("\t\tp{}_{}.defaultValStr = {}_{}_defval;\n", pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	}

	sourcefileBody_ += fmt::format("\t\tp{}Module.propertys[\"{}\"] = p{}_{}; \n\n", 
		pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	if (pDescr->aliasID() != -1)
	{
		sourcefileBody_ += fmt::format("\t\tp{}Module.usePropertyDescrAlias = true;\n", pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\tp{}Module.idpropertys[DataTypes.NumberUtil.toUInt16(p{}_{}.aliasID)] = p{}_{};  // 可能需要转(UInt16)\n\n",
			pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\tp{}Module.usePropertyDescrAlias = false;\n", pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\tp{}Module.idpropertys[p{}_{}.properUtype] = p{}_{};\n\n",
			pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	}

	sourcefileBody_ += fmt::format("\t\t//Dbg.DEBUG_MSG(\"EntityDef::initScriptModules: add({}), property({} / {}).\");\n\n",
		pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypesBegin()
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");


	sourcefileBody_ += "\nexport namespace KBETypes {\n";
	sourcefileBody_ += "\n// defined in */entity_defs/types.xml\n\n";
	//sourcefileBody_ += "\n\nimport { Vector2, Vector3, Vector4 } from \"./KBEMath\";\n// defined in */entity_defs/types.xml\n\n";

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypesEnd()
{
	//sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeBegin(std::string typeName, FixedDictType* pDataType)
{
	sourcefileBody_ += fmt::format("export class {}{{\n", typeName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeEnd(std::string typeName, FixedDictType* pDataType)
{
	sourcefileBody_ += "\n}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeBegin(std::string typeName, FixedArrayType* pDataType, const std::string& parentClass)
{
	sourcefileBody_ += fmt::format("export class {}{}{{\n", typeName, (parentClass.size() > 0 ? std::string(" extends ") + parentClass : ""));
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeEnd(std::string typeName, FixedArrayType* pDataType)
{
	sourcefileBody_ += "\n}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeBegin(std::string typeName, DataType* pDataType)
{
	sourcefileBody_ += fmt::format("export type {} = ", typeName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeEnd(std::string typeName, DataType* pDataType)
{
	//sourcefileBody_ += "\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_AliasName(const std::string& itemName, const std::string& childItemName)
{
	if (childItemName == "UINT8" || childItemName == "UINT16" || childItemName == "UINT32" || childItemName == "UINT64" || 
		childItemName == "INT8" || childItemName == "INT16" || childItemName == "INT32" || childItemName == "INT64" || 
		childItemName == "FLOAT" || childItemName == "DOUBLE")
	{
		std::string ntype = typeToType(childItemName);
		sourcefileBody_ += fmt::format("{}; \n", ntype);
		//sourcefileBody_ += fmt::format("\t\t{} value;\n\n", ntype);
		//sourcefileBody_ += fmt::format("\t\t{}({} value)\n\t\t{{\n", itemName, ntype);
		//sourcefileBody_ += fmt::format("\t\t\tthis.value = value;\n\t\t}}\n\n");

		//sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", ntype, itemName);
		//sourcefileBody_ += fmt::format("\t\t\treturn value.value;\n\t\t}}\n\n");

		//sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", itemName, ntype);
		//sourcefileBody_ += fmt::format("\t\t\t{} tvalue = ({})value;\n\t\t\treturn new {}(tvalue);\n\t\t}}\n\n", ntype, ntype, itemName);

		//sourcefileBody_ += fmt::format("\t\tpublic static {} MaxValue\n\t\t{{\n", ntype);
		//sourcefileBody_ += fmt::format("\t\t\tget\n\t\t\t{{\n\t\t\t\treturn {}.MaxValue;\n\t\t\t}}\n\t\t}}\n\n", ntype);

		//sourcefileBody_ += fmt::format("\t\tpublic static {} MinValue\n\t\t{{\n", ntype);
		//sourcefileBody_ += fmt::format("\t\t\tget\n\t\t\t{{\n\t\t\t\treturn {}.MinValue;\n\t\t\t}}\n\t\t}}\n", ntype);

	}
	else if (childItemName == "STRING" || childItemName == "UNICODE")
	{
		//std::string ntype = typeToType(childItemName);
		//sourcefileBody_ += fmt::format("\t\t{} value;\n\n", ntype);
		//sourcefileBody_ += fmt::format("\t\t{}({} value)\n\t\t{{\n", itemName, ntype);
		//sourcefileBody_ += fmt::format("\t\t\tthis.value = value;\n\t\t}}\n\n");

		//sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", ntype, itemName);
		//sourcefileBody_ += fmt::format("\t\t\treturn value.value;\n\t\t}}\n\n");

		//sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", itemName, ntype);
		//sourcefileBody_ += fmt::format("\t\t\t{} tvalue = ({})value;\n\t\t\treturn new {}(tvalue);\n\t\t}}\n", ntype, ntype, itemName);

		std::string ntype = typeToType(childItemName);
		sourcefileBody_ += fmt::format("{}; \n", ntype);
	}
	else if (childItemName == "PYTHON" || childItemName == "PY_DICT" || childItemName == "PY_TUPLE" || 
		childItemName == "PY_LIST" || childItemName == "ENTITYCALL" || childItemName == "BLOB")
	{
		std::string ntype = "Uint8Array";
		sourcefileBody_ += fmt::format("{}; \n", ntype);
		/*sourcefileBody_ += fmt::format("\t\t{} value;\n\n", ntype);
		sourcefileBody_ += fmt::format("\t\t{}({} value)\n\t\t{{\n", itemName, ntype);
		sourcefileBody_ += fmt::format("\t\t\tthis.value = value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", ntype, itemName);
		sourcefileBody_ += fmt::format("\t\t\treturn value.value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}(byte[] value)\n\t\t{{\n", itemName);
		sourcefileBody_ += fmt::format("\t\t\t{} tvalue = ({})value;\n\t\t\treturn new {}(tvalue);\n\t\t}}\n\n", ntype, ntype, itemName);

		sourcefileBody_ += fmt::format("\t\tpublic Byte this[int ID]\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\tget {{ return value[ID]; }}\n\t\t\tset {{ this.value[ID] = value; }}\n\t\t}}\n");*/
	}
	else if (childItemName == "VECTOR2" || childItemName == "VECTOR3" || childItemName == "VECTOR4")
	{
		std::string ntype = typeToType(childItemName);
		//sourcefileBody_ += fmt::format("\t\t{} value;\n\n", ntype);
		//sourcefileBody_ += fmt::format("\t\t{}({} value)\n\t\t{{\n", itemName, ntype);
		//sourcefileBody_ += fmt::format("\t\t\tthis.value = value;\n\t\t}}\n\n");

		//sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", ntype, itemName);
		//sourcefileBody_ += fmt::format("\t\t\treturn value.value;\n\t\t}}\n\n");

		//sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", itemName, ntype);
		//sourcefileBody_ += fmt::format("\t\t\t{} tvalue = ({})value;\n\t\t\treturn new {}(tvalue);\n\t\t}}\n\n", ntype, ntype, itemName);

		//sourcefileBody_ += fmt::format("\t\tpublic float x\n\t\t{{\n", ntype, itemName);
		//sourcefileBody_ += fmt::format("\t\t\tget {{ return value.x; }}\n\t\t\tset {{ this.value.x = value; }}\n\t\t}}\n\n");

		//sourcefileBody_ += fmt::format("\t\tpublic float y\n\t\t{{\n", ntype, itemName);
		//sourcefileBody_ += fmt::format("\t\t\tget {{ return value.y; }}\n\t\t\tset {{ this.value.y = value; }}\n\t\t}}\n\n");

		//if (ntype == "Vector2")
		//{
		//	sourcefileBody_ += "{ x: number; y: number; };\n";
		//}

		//if (ntype == "Vector3")
		//{
		//	sourcefileBody_ += "{ x: number; y: number; z: number; };\n";
		//}

		//if (ntype == "Vector4")
		//{
		//	sourcefileBody_ += "{ x: number; y: number; z: number; w: number; };\n";
		//}

		sourcefileBody_ += fmt::format("{};\n", ntype);
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_INT8(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_INT16(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_INT32(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_INT64(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:bigint = 0n;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_UINT8(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_UINT16(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_UINT32(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_UINT64(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:bigint = 0n;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_FLOAT(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_DOUBLE(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_STRING(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:string = \"\";\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_UNICODE(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:string = \"\";\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_PYTHON(const std::string& itemName, const std::string& childItemName)
{
	return writeTypeItemType_BLOB(itemName, childItemName);
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_PY_DICT(const std::string& itemName, const std::string& childItemName)
{
	return writeTypeItemType_BLOB(itemName, childItemName);
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_PY_TUPLE(const std::string& itemName, const std::string& childItemName)
{
	return writeTypeItemType_BLOB(itemName, childItemName);
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_PY_LIST(const std::string& itemName, const std::string& childItemName)
{
	return writeTypeItemType_BLOB(itemName, childItemName);
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_BLOB(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:Uint8Array = new Uint8Array();\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_ARRAY(const std::string& itemName, const std::string& childItemName, DataType* pDataType)
{
	std::string typeStr;

	if (childItemName.size() == 0 || childItemName[0] == '_')
	{
		getArrayType(pDataType, typeStr);
	}
	else
	{
		typeStr = childItemName;
	}

	sourcefileBody_ += fmt::format("\tpublic {}:{} = new {}();\n", itemName, typeStr, typeStr);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_FIXED_DICT(const std::string& itemName, const std::string& childItemName, DataType* pDataType)
{
	sourcefileBody_ += fmt::format("\tpublic {}:{} = new {}();\n", itemName, childItemName, childItemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_VECTOR2(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector2Int {} = new Vector2Int(0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\tpublic {}:Vector2 = new Vector2(0, 0);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_VECTOR3(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector3Int {} = new Vector3Int(0, 0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\tpublic {}:Vector3 = new Vector3(0, 0, 0);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_VECTOR4(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector4Int {} = new Vector4Int(0, 0, 0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\tpublic {}:Vector4 = new Vector4(0, 0, 0, 0);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeTypeItemType_ENTITYCALL(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\tpublic {}:Uint8Array = new Uint8Array();\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityModuleBegin(ScriptDefModule* pEntityScriptDefModule)
{
	std::string newModuleName = fmt::format("{}{}", pEntityScriptDefModule->getName(), moduleSuffix);

	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", fmt::format("\tPlease inherit this module, such as: (class {} extends {}{})\n",
		pEntityScriptDefModule->getName(), pEntityScriptDefModule->getName(), moduleSuffix));

	sourcefileBody_ += R"delimiter(
import {Entity , EntityComponent , EntityCall , MemoryStream , DataTypes , KBETypes} from './KBEngine';
import * as ExportEntity from './ExportEntity';

import { Method } from './Method';
import { ScriptModule } from './ScriptModule';
import EntityDef from './EntityDef';
import { Property } from './Property';
import { Vector2, Vector3, Vector4 } from './KBEMath';

)delimiter";


	sourcefileBody_ += fmt::format("import {{ EntityBaseEntityCall_{}, EntityCellEntityCall_{} }} from './EntityCall{}';\n\n", newModuleName, newModuleName, newModuleName);




	{
		std::set<std::string> uniqueEntityComponenStrings;
		ScriptDefModule::PROPERTYDESCRIPTION_MAP& clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() == DATA_TYPE_ENTITY_COMPONENT)
			{
				EntityComponentType* pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();

				//sourcefileBody_ += fmt::format("import {{ {}{} }} from './{}{}';\n" , pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix);

				uniqueEntityComponenStrings.insert(fmt::format("{}{}",  pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix));
			}
		}

		for (auto it = uniqueEntityComponenStrings.begin(); it != uniqueEntityComponenStrings.end(); ++it) {
			sourcefileBody_ += fmt::format("import {{ {} }} from './{}';\n", *it, *it);
		}

		// 格式化为 "a", "b", "c"
		//std::ostringstream oss;
		//for (auto it = uniqueEntityComponenStrings.begin(); it != uniqueEntityComponenStrings.end(); ++it) {
		//	if (it != uniqueEntityComponenStrings.begin()) {
		//		oss << ", ";
		//	}
		//	oss << "\"" << *it << "\"";
		//}

		//std::string result = oss.str();
		//if (!result.empty()) {
		//	sourcefileBody_ += fmt::format("import {{ {} }} from './EntityCall{}';\n\n", result);
		//}

		

	}


	sourcefileBody_ += std::string("// defined in */scripts/entity_defs/") + pEntityScriptDefModule->getName() + ".def\n";

	if (pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("export abstract class {} extends EntityComponent{{\n", newModuleName);

		// 写entityCall属性
		sourcefileBody_ += fmt::format("\tpublic baseEntityCall:EntityBaseEntityCall_{} | null = null;\n", newModuleName);
		sourcefileBody_ += fmt::format("\tpublic cellEntityCall:EntityCellEntityCall_{} | null = null;\n\n", newModuleName);
	}
	else
	{
		sourcefileBody_ += fmt::format("// Please inherit and implement \"class {} extends {}\"\n", pEntityScriptDefModule->getName(), newModuleName);
		sourcefileBody_ += fmt::format("export abstract class {} extends Entity{{\n", newModuleName);

		// 写entityCall属性
		sourcefileBody_ += fmt::format("\tpublic baseEntityCall:EntityBaseEntityCall_{} | null = null;\n", newModuleName);
		sourcefileBody_ += fmt::format("\tpublic cellEntityCall:EntityCellEntityCall_{} | null = null;\n\n", newModuleName);
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityModuleEnd(ScriptDefModule* pEntityScriptDefModule)
{
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::getArrayType(DataType* pDataType, std::string& outstr)
{
	if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
	{
		FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

		// 如果元素又是数组
		if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDARRAY)
		{
			if (outstr.size() > 0)
				strutil::kbe_replace(outstr, pDataType->aliasName(), fmt::format("Array<{}>", pFixedArrayType->getDataType()->aliasName()));
			else
				outstr = fmt::format("Array<{}>", pFixedArrayType->getDataType()->aliasName());

			return getArrayType(pFixedArrayType->getDataType(), outstr);
		}
		else if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDDICT)
		{
			if (outstr.size() > 0)
				strutil::kbe_replace(outstr, pDataType->aliasName(), pFixedArrayType->getDataType()->aliasName());
			else
				outstr = pFixedArrayType->getDataType()->aliasName();
		}
		else
		{
			if (outstr.size() > 0)
				strutil::kbe_replace(outstr, pDataType->aliasName(), typeToType(pFixedArrayType->getDataType()->getName()));
			else
				outstr = typeToType(pFixedArrayType->getDataType()->getName());
		}
	}

	outstr = fmt::format("Array<{}>", outstr);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProcessMessagesMethod(ScriptDefModule* pEntityScriptDefModule)
{
	std::string ownstr = "";
	if (pEntityScriptDefModule->isComponentModule())
		ownstr = "owner.";

	// entityCall
	std::string newModuleName = fmt::format("{}{}", pEntityScriptDefModule->getName(), moduleSuffix);

	if (pEntityScriptDefModule->isComponentModule())
	{

		sourcefileBody_ += R"delimiter(
	public override  createFromStream(stream:MemoryStream )
	{
		super.createFromStream(stream);
	}
)delimiter";
		
		std::string onGetBaseTpl = R"delimiter(
	public override onGetBase()
	{{
		this.ownerID = this.owner.id;
		this.baseEntityCall = new EntityBaseEntityCall_{}(this.entityComponentPropertyID, this.ownerID);
	}}
)delimiter";


		std::string onGetCellTpl = R"delimiter(
	public override onGetCell()
	{{
		this.ownerID = this.owner.id;
		this.cellEntityCall = new EntityCellEntityCall_{}(this.entityComponentPropertyID, this.ownerID);
	}}
)delimiter";


		std::string onLoseCellTpl = R"delimiter(
	public override onLoseCell()
	{{
		this.cellEntityCall = null;
	}}
)delimiter";

		sourcefileBody_ += fmt::format(onGetBaseTpl, newModuleName);
		sourcefileBody_ += fmt::format(onGetCellTpl, newModuleName);
		sourcefileBody_ += fmt::format(onLoseCellTpl, newModuleName);

		/*sourcefileBody_ += fmt::format("\n\tpublic override void onGetBase()\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\townerID = owner.id;\n");
		sourcefileBody_ += fmt::format("\t\tbaseEntityCall = new EntityBaseEntityCall_{}(entityComponentPropertyID, ownerID);\n", newModuleName);
		sourcefileBody_ += fmt::format("\t}}\n");

		sourcefileBody_ += fmt::format("\n\tpublic override void onGetCell()\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\townerID = owner.id;\n");
		sourcefileBody_ += fmt::format("\t\tcellEntityCall = new EntityCellEntityCall_{}(entityComponentPropertyID, ownerID);\n", newModuleName);
		sourcefileBody_ += fmt::format("\t}}\n");

		sourcefileBody_ += fmt::format("\n\tpublic override void onLoseCell()\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\tcellEntityCall = null;\n", newModuleName);
		sourcefileBody_ += fmt::format("\t}}\n");*/
	}

	if (!pEntityScriptDefModule->isComponentModule())
	{
		//sourcefileBody_ += fmt::format("\n\tpublic {}(){{\n", newModuleName);

		sourcefileBody_ += R"delimiter(
	constructor(){
		super();
)delimiter";

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();



			std::string loadEntityTpl = R"delimiter(
		{{
			let entityComponentScript = ExportEntity.GetEntityScript("{}");
			if(entityComponentScript != null){{
				this.{} = new entityComponentScript();
				this.{}!.owner = this;
				this.{}!.entityComponentPropertyID = {};
				this.{}!.name_ = "{}";
			}}
		}}


		if(this.{} == null)
			throw new Error("Please inherit and implement, such as: class {} extends {}{}");

)delimiter";

			sourcefileBody_ += fmt::format(loadEntityTpl, pEntityComponentType->pScriptDefModule()->getName(),
				pPropertyDescription->getName(),
				pPropertyDescription->getName(),
				pPropertyDescription->getName(), pPropertyDescription->getUType(),
				pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(),
				pPropertyDescription->getName(),
				pEntityComponentType->pScriptDefModule()->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix);

			/*sourcefileBody_ += fmt::format("\t\tforeach (System.Reflection.Assembly ass in AppDomain.CurrentDomain.GetAssemblies())\n\t\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\tType entityComponentScript = ass.GetType(\"KBEngine.{}\");\n", pEntityComponentType->pScriptDefModule()->getName());
			sourcefileBody_ += fmt::format("\t\t\tif(entityComponentScript != null)\n\t\t\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t\t{} = ({}{})Activator.CreateInstance(entityComponentScript);\n", pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix);
			sourcefileBody_ += fmt::format("\t\t\t\t{}.owner = this;\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t{}.entityComponentPropertyID = {};\n", pPropertyDescription->getName(), pPropertyDescription->getUType());
			sourcefileBody_ += fmt::format("\t\t\t\t{}.name_ = \"{}\";\n", pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName());
			sourcefileBody_ += fmt::format("\t\t\t}}\n\t\t}}\n\n");

			sourcefileBody_ += fmt::format("\t\tif({} == null)\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\tthrow new Exception(\"Please inherit and implement, such as: \\\"class {} : {}{}\\\"\");\n\n", pEntityComponentType->pScriptDefModule()->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix);*/
		}

		sourcefileBody_ += "\t}\n";

		sourcefileBody_ += fmt::format("\n\tpublic override onComponentsEnterworld(){{\n");
		propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			sourcefileBody_ += fmt::format("\t\tthis.{}!.onEnterworld?.();\n", pPropertyDescription->getName());
		}

		sourcefileBody_ += "\t}\n";

		sourcefileBody_ += fmt::format("\n\tpublic override onComponentsLeaveworld(){{\n");
		propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			sourcefileBody_ += fmt::format("\t\t\tthis.{}!.onLeaveworld?.();\n", pPropertyDescription->getName());
		}

		sourcefileBody_ += "\t}\n";

		std::vector<PropertyDescription*> components;
		propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() == DATA_TYPE_ENTITY_COMPONENT)
				components.push_back(pPropertyDescription);
		}

		if (!components.empty())
		{
			sourcefileBody_ += fmt::format("\n\tpublic override getComponents(componentName: string, all: boolean) : EntityComponent[] {{\n");
			sourcefileBody_ += fmt::format("\t\tlet founds: EntityComponent[] = [];\n\n");
			std::vector<PropertyDescription*>::const_iterator iter = components.begin();
			for (; iter != components.end(); ++iter)
			{
				PropertyDescription* pPropertyDescription = *iter;
				sourcefileBody_ += fmt::format("\t\tif (this.{}!.name_ == componentName){{\n", pPropertyDescription->getName());
				sourcefileBody_ += fmt::format("\t\t\tfounds.push(this.{}!);\n", pPropertyDescription->getName());
				sourcefileBody_ += fmt::format("\t\t\tif (!all)\n");
				sourcefileBody_ += fmt::format("\t\t\t\treturn founds;\n\t\t}}\n\n");
			}

			sourcefileBody_ += "\t\treturn founds;\n";
			sourcefileBody_ += "\t}\n";
		}
			
		sourcefileBody_ += fmt::format("\n\tpublic override onGetBase(){{\n");
		sourcefileBody_ += fmt::format("\t\tthis.baseEntityCall = new EntityBaseEntityCall_{}(this.id, this.className);\n", newModuleName);
		propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			sourcefileBody_ += fmt::format("\t\tthis.{}!.onGetBase();\n", pPropertyDescription->getName());
		}
		sourcefileBody_ += "\t}\n";

		sourcefileBody_ += fmt::format("\n\tpublic override onGetCell(){{\n");
		sourcefileBody_ += fmt::format("\t\tthis.cellEntityCall = new EntityCellEntityCall_{}(this.id, this.className);\n", newModuleName);
		propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			sourcefileBody_ += fmt::format("\t\tthis.{}!.onGetCell();\n", pPropertyDescription->getName());
		}
		sourcefileBody_ += "\t}\n";

		sourcefileBody_ += fmt::format("\n\tpublic override onLoseCell(){{\n");
		sourcefileBody_ += fmt::format("\t\tthis.cellEntityCall = null;\n");
		propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			sourcefileBody_ += fmt::format("\t\tthis.{}!.onLoseCell();\n", pPropertyDescription->getName());
		}
		sourcefileBody_ += "\t}\n";

		sourcefileBody_ += fmt::format("\n\tpublic override getBaseEntityCall(){{\n");
		sourcefileBody_ += fmt::format("\t\treturn this.baseEntityCall;\n");
		sourcefileBody_ += "\t}\n";

		sourcefileBody_ += fmt::format("\n\tpublic override getCellEntityCall(){{\n");
		sourcefileBody_ += fmt::format("\t\treturn this.cellEntityCall;\n");
		sourcefileBody_ += "\t}\n";
	}

	// attach/detach组件
	if (!pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\n\tpublic override attachComponents(){{\n");
		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			sourcefileBody_ += fmt::format("\t\tthis.{}!.onAttached?.(this);\n", pPropertyDescription->getName());
		}

		sourcefileBody_ += "\t}\n";

		sourcefileBody_ += fmt::format("\n\tpublic override detachComponents(){{\n");
		propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			sourcefileBody_ += fmt::format("\t\tthis.{}!.onDetached?.(this);\n", pPropertyDescription->getName());
		}

		sourcefileBody_ += "\t}\n";
	}

	if (pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\n\tpublic override getScriptModule() : ScriptModule{{\n");
		sourcefileBody_ += fmt::format("\t\treturn EntityDef.moduledefs[\"{}\"];\n", pEntityScriptDefModule->getName());
		sourcefileBody_ += "\t}\n";
	}

	// 处理方法
	if (!pEntityScriptDefModule->isComponentModule())
		sourcefileBody_ += fmt::format("\n\tpublic override onRemoteMethodCall(stream:MemoryStream){{\n");
	else
		sourcefileBody_ += fmt::format("\n\tpublic override onRemoteMethodCall(methodUtype:number, stream:MemoryStream){{\n");

	sourcefileBody_ += fmt::format("\t\tlet sm:ScriptModule = EntityDef.moduledefs[\"{}\"];\n\n", pEntityScriptDefModule->getName());
	
	if (!pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\t\tlet methodUtype = 0;\n");
		sourcefileBody_ += fmt::format("\t\tlet componentPropertyUType = 0;\n\n");

		sourcefileBody_ += fmt::format("\t\tif(sm.usePropertyDescrAlias){{\n");
		sourcefileBody_ += fmt::format("\t\t\tcomponentPropertyUType = stream.ReadUint8();\n");
		sourcefileBody_ += fmt::format("\t\t}}\n");
		sourcefileBody_ += fmt::format("\t\telse{{\n");
		sourcefileBody_ += fmt::format("\t\t\tcomponentPropertyUType = stream.ReadUint16();\n");
		sourcefileBody_ += fmt::format("\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tif(sm.useMethodDescrAlias){{\n");
		sourcefileBody_ += fmt::format("\t\t\tmethodUtype = stream.ReadUint8();\n");

		bool foundComponentNoUseMethodDescrAlias = false;

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();
			if (!pEntityComponentType->pScriptDefModule()->useMethodDescrAlias())
			{
				foundComponentNoUseMethodDescrAlias = true;
				break;
			}
		}

		if (foundComponentNoUseMethodDescrAlias)
		{
			sourcefileBody_ += fmt::format("\n\t\t\tif(componentPropertyUType > 0){{\n");
			sourcefileBody_ += fmt::format("\t\t\t\tlet useComponentMethodDescrAlias = true;\n");
			sourcefileBody_ += fmt::format("\t\t\t\tlet pComponentPropertyDescription:Property = sm.idpropertys[componentPropertyUType];\n\n");
			sourcefileBody_ += fmt::format("\t\t\t\tswitch(pComponentPropertyDescription.properUtype){{\n");

			for (propIter = clientPropertys.begin(); propIter != clientPropertys.end(); ++propIter)
			{
				PropertyDescription* pPropertyDescription = propIter->second;

				if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
					continue;

				EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();
				if (!pEntityComponentType->pScriptDefModule()->useMethodDescrAlias())
				{
					sourcefileBody_ += fmt::format("\t\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
					sourcefileBody_ += fmt::format("\t\t\t\t\t\tuseComponentMethodDescrAlias = false;\n", pPropertyDescription->getName());
					sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
				}
			}

			sourcefileBody_ += fmt::format("\t\t\t\t\tdefault:\n");
			sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
			sourcefileBody_ += fmt::format("\t\t\t\t}}\n\n");

			sourcefileBody_ += fmt::format("\t\t\t\tif(!useComponentMethodDescrAlias)\n");
			sourcefileBody_ += fmt::format("\t\t\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t\t\tstream.rpos -= 1;\n");
			sourcefileBody_ += fmt::format("\t\t\t\t\tmethodUtype = stream.ReadUint16();\n");
			sourcefileBody_ += fmt::format("\t\t\t\t}}\n");

			sourcefileBody_ += fmt::format("\t\t\t}}\n");
		}

		sourcefileBody_ += fmt::format("\t\t}}\n");
		sourcefileBody_ += fmt::format("\t\telse\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\tmethodUtype = stream.ReadUint16();\n");
		sourcefileBody_ += fmt::format("\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tlet method:Method | null = null;\n\n");

		sourcefileBody_ += fmt::format("\t\tif(componentPropertyUType == 0)\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\tmethod = sm.idmethods[methodUtype];\n");
		sourcefileBody_ += fmt::format("\t\t}}\n");
		sourcefileBody_ += fmt::format("\t\telse\n");
		sourcefileBody_ += fmt::format("\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\tlet pComponentPropertyDescription:Property = sm.idpropertys[componentPropertyUType];\n");

		sourcefileBody_ += fmt::format("\t\t\tswitch(pComponentPropertyDescription.properUtype){{\n");

		for (propIter = clientPropertys.begin(); propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			sourcefileBody_ += fmt::format("\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
			sourcefileBody_ += fmt::format("\t\t\t\t\tthis.{}!.onRemoteMethodCall(methodUtype, stream);\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
		}

		sourcefileBody_ += fmt::format("\t\t\t\tdefault:\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
		sourcefileBody_ += fmt::format("\t\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\t\treturn;\n");
		sourcefileBody_ += fmt::format("\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tswitch(method!.methodUtype){{\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\tlet method:Method = sm.idmethods[methodUtype];\n");
		sourcefileBody_ += fmt::format("\t\tswitch(method!.methodUtype){{\n");
	}

	ScriptDefModule::METHODDESCRIPTION_MAP& clientMethods = pEntityScriptDefModule->getClientMethodDescriptions();
	ScriptDefModule::METHODDESCRIPTION_MAP::iterator methodIter = clientMethods.begin();
	for (; methodIter != clientMethods.end(); ++methodIter)
	{
		MethodDescription* pMethodDescription = methodIter->second;

		sourcefileBody_ += fmt::format("\t\t\tcase {}:\n", pMethodDescription->getUType());
		
		std::vector<DataType*>& argTypes = pMethodDescription->getArgTypes();
		std::vector<DataType*>::iterator iter = argTypes.begin();

		int i = 1;
		std::string argsStr;

		for (; iter != argTypes.end(); ++iter)
		{
			DataType* pDataType = (*iter);

			uint16 typeID = datatype2id(pDataType->getName());
			if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
				typeID = pDataType->id();

			argsStr += fmt::format("{}_arg{}, ", pMethodDescription->getName(), i);

			std::string readName = datatype2nativetype(pDataType->getName());
			if (readName.size() > 0)
			{
				std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
				readName[0] = std::toupper(readName[0]);
			}

			std::string nativetype = datatype2nativetype(typeID);
			if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
			{
				sourcefileBody_ += fmt::format("\t\t\t\tlet {}_arg{}:{}{} = method.args[{}].createFromStreamEx(stream);\n",
					pMethodDescription->getName(), i, (datatype2nativetype(pDataType->aliasName()) == "" ? "KBETypes." : ""), pDataType->aliasName(), (i - 1));
			}
			else if(strcmp(pDataType->getName(), "ARRAY") == 0)
			{
				std::string typestr;
				getArrayType(pDataType, typestr);

				if (strlen(pDataType->aliasName()) > 0)
				{
					sourcefileBody_ += fmt::format("\t\t\t\tlet {}_arg{}:{}{} = method.args[{}].createFromStreamEx(stream);\n",
						pMethodDescription->getName(), i, (datatype2nativetype(pDataType->aliasName()) == "" ? "KBETypes." : ""), pDataType->aliasName(), (i - 1));
				}
				else
				{
					sourcefileBody_ += fmt::format("\t\t\t\tlet {}_arg{}:{}{} = (method.args[{}] as DATATYPE_AnonymousArray_{}).createFromStreamEx(stream);\n",
						pMethodDescription->getName(), i, (datatype2nativetype(typestr) == "" ? "KBETypes." : ""), typestr, typeID, (i - 1));
				}
			}
			else
			{
				if (readName == "Uint64" || readName == "Int64") {
					sourcefileBody_ += fmt::format("\t\t\t\tlet {}_arg{}:{} = stream.Read{}().toBigInt();\n",
						pMethodDescription->getName(), i, typeToType(nativetype), readName);
				}
				else {
					sourcefileBody_ += fmt::format("\t\t\t\tlet {}_arg{}:{} = stream.Read{}();\n",
						pMethodDescription->getName(), i, typeToType(nativetype), readName);
				}
				
			}

			++i;
		}

		if (argsStr.size() > 0)
			argsStr.erase(argsStr.size() - 2, 2);

		sourcefileBody_ += fmt::format("\t\t\t\tthis.{}({});\n", pMethodDescription->getName(), argsStr);
		sourcefileBody_ += fmt::format("\t\t\t\tbreak;\n");
	}

	sourcefileBody_ += fmt::format("\t\t\tdefault:\n");
	sourcefileBody_ += fmt::format("\t\t\t\tbreak;\n");
	sourcefileBody_ += fmt::format("\t\t}};\n");
	sourcefileBody_ += "\t}\n";

	// 处理属性
	ENTITY_PROPERTY_UID posuid = 0;
	if (posuid == 0)
	{
		posuid = ENTITY_BASE_PROPERTY_UTYPE_POSITION_XYZ;
		Network::FixedMessages::MSGInfo* msgInfo =
			Network::FixedMessages::getSingleton().isFixed("Property::position");

		if (msgInfo != NULL)
			posuid = msgInfo->msgid;
	}

	PropertyDescription positionDescription(posuid, "VECTOR3", "position", ED_FLAG_ALL_CLIENTS, true, DataTypes::getDataType("VECTOR3"), false, "", 0, "", DETAIL_LEVEL_FAR);
	if (pEntityScriptDefModule->usePropertyDescrAlias() && positionDescription.aliasID() == -1)
		positionDescription.aliasID(ENTITY_BASE_PROPERTY_ALIASID_POSITION_XYZ);

	ENTITY_PROPERTY_UID diruid = 0;
	if (diruid == 0)
	{
		diruid = ENTITY_BASE_PROPERTY_UTYPE_DIRECTION_ROLL_PITCH_YAW;
		Network::FixedMessages::MSGInfo* msgInfo = Network::FixedMessages::getSingleton().isFixed("Property::direction");
		if (msgInfo != NULL)
			diruid = msgInfo->msgid;
	}

	PropertyDescription directionDescription(diruid, "VECTOR3", "direction", ED_FLAG_ALL_CLIENTS, true, DataTypes::getDataType("VECTOR3"), false, "", 0, "", DETAIL_LEVEL_FAR);
	if (pEntityScriptDefModule->usePropertyDescrAlias() && directionDescription.aliasID() == -1)
		directionDescription.aliasID(ENTITY_BASE_PROPERTY_ALIASID_DIRECTION_ROLL_PITCH_YAW);

	ENTITY_PROPERTY_UID spaceuid = 0;
	if (spaceuid == 0)
	{
		spaceuid = ENTITY_BASE_PROPERTY_UTYPE_SPACEID;
		Network::FixedMessages::MSGInfo* msgInfo = Network::FixedMessages::getSingleton().isFixed("Property::spaceID");
		if (msgInfo != NULL)
			spaceuid = msgInfo->msgid;
	}

	PropertyDescription spaceDescription(spaceuid, "UINT32", "spaceID", ED_FLAG_OWN_CLIENT, true, DataTypes::getDataType("UINT32"), false, "", 0, "", DETAIL_LEVEL_FAR);
	if (pEntityScriptDefModule->usePropertyDescrAlias() && spaceDescription.aliasID() == -1)
		spaceDescription.aliasID(ENTITY_BASE_PROPERTY_ALIASID_SPACEID);

	if(pEntityScriptDefModule->isComponentModule())
		sourcefileBody_ += fmt::format("\n\tpublic override onUpdatePropertys(propUtype:number, stream:MemoryStream, maxCount:number){{\n");
	else
		sourcefileBody_ += fmt::format("\n\tpublic override onUpdatePropertys(stream:MemoryStream){{\n");

	sourcefileBody_ += fmt::format("\t\tlet sm:ScriptModule = EntityDef.moduledefs[\"{}\"];\n", pEntityScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\tlet pdatas = sm.idpropertys;\n\n");

	if (pEntityScriptDefModule->isComponentModule())
		sourcefileBody_ += fmt::format("\t\twhile(stream.Length() > 0 && maxCount-- != 0)\n");
	else
		sourcefileBody_ += fmt::format("\t\twhile(stream.Length() > 0)\n");

	sourcefileBody_ += fmt::format("\t\t{{\n");

	sourcefileBody_ += fmt::format("\t\t\tlet _t_utype:number = 0;\n");

	if (pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\t\t\tlet _t_child_utype:number = propUtype;\n\n");
		sourcefileBody_ += fmt::format("\t\t\tif(_t_child_utype == 0)\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\tlet _t_child_utype:number = 0;\n\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\t\tif(sm.usePropertyDescrAlias){{\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t_t_utype = stream.ReadUint8();\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t_t_child_utype = stream.ReadUint8();\n");
	sourcefileBody_ += fmt::format("\t\t\t\t}}\n");
	sourcefileBody_ += fmt::format("\t\t\t\telse\n");
	sourcefileBody_ += fmt::format("\t\t\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t_t_utype = stream.ReadUint16();\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t_t_child_utype = stream.ReadUint16();\n");
	sourcefileBody_ += fmt::format("\t\t\t\t}}\n");
	sourcefileBody_ += fmt::format("\t\t\t}}\n\n");

	sourcefileBody_ += fmt::format("\t\t\tlet prop:Property | null = null;\n\n");

	if (pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\t\t\tprop = pdatas[_t_child_utype];\n\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\tif(_t_utype == 0){{\n");
		sourcefileBody_ += fmt::format("\t\t\t\tprop = pdatas[_t_child_utype];\n");
		sourcefileBody_ += fmt::format("\t\t\t}}\n");
		sourcefileBody_ += fmt::format("\t\t\telse\n");
		sourcefileBody_ += fmt::format("\t\t\t{{\n");

		sourcefileBody_ += fmt::format("\t\t\t\tlet pComponentPropertyDescription:Property = pdatas[_t_utype];\n");

		sourcefileBody_ += fmt::format("\t\t\t\tswitch(pComponentPropertyDescription.properUtype)\n\t\t\t\t\t{{\n");

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;


			sourcefileBody_ += fmt::format("\t\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
			sourcefileBody_ += fmt::format("\t\t\t\t\t\tthis.{}!.onUpdatePropertys(_t_child_utype, stream, -1);\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
		}

		sourcefileBody_ += fmt::format("\t\t\t\t\tdefault:\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
		sourcefileBody_ += fmt::format("\t\t\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\t\t\treturn;\n");
		sourcefileBody_ += fmt::format("\t\t\t}}\n\n");
	}

	sourcefileBody_ += fmt::format("\t\t\tswitch(prop!.properUtype){{\n");

	ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();

	if (!pEntityScriptDefModule->isComponentModule())
	{
		clientPropertys[positionDescription.getName()] = &positionDescription;
		clientPropertys[directionDescription.getName()] = &directionDescription;
		clientPropertys[spaceDescription.getName()] = &spaceDescription;
	}

	ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
	for (; propIter != clientPropertys.end(); ++propIter)
	{
		PropertyDescription* pPropertyDescription = propIter->second;

		if (pPropertyDescription->getDataType()->type() == DATA_TYPE_ENTITY_COMPONENT)
		{
			sourcefileBody_ += fmt::format("\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
			sourcefileBody_ += fmt::format("\t\t\t\t\tthis.{}!.createFromStream(stream);\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
			continue;
		}

		std::string typestr;

		if (std::string("position") == pPropertyDescription->getName() ||
			std::string("direction") == pPropertyDescription->getName())
		{
#ifdef CLIENT_NO_FLOAT
			typestr = "Vector3Int";
#else
			typestr = "Vector3";
#endif
		}
		else
		{
			if (std::string("spaceID") == pPropertyDescription->getName())
			{
				sourcefileBody_ += fmt::format("\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
				sourcefileBody_ += fmt::format("\t\t\t\t\tstream.ReadUint32();\n");
				sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
				continue;
			}
			else
			{
				/*std::string findstr = fmt::format(" {} = ", pPropertyDescription->getName());
				std::string::size_type fpos2 = sourcefileBody_.find(findstr);
				std::string::size_type fpos1 = sourcefileBody_.rfind(" ", fpos2 - 1);
				typestr.assign(sourcefileBody_.begin() + fpos1 + 1, sourcefileBody_.begin() + fpos2);*/

				std::string findstr = fmt::format(" {}:", pPropertyDescription->getName());
				std::string::size_type fpos2 = sourcefileBody_.find(findstr);
				std::string::size_type fpos1 = sourcefileBody_.find(" ", fpos2 + 1);
				// 这里获取类型，要处理
				typestr.assign(sourcefileBody_.begin() + fpos2 + findstr.length() , sourcefileBody_.begin() + fpos1);
			}
		}

		sourcefileBody_ += fmt::format("\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
		sourcefileBody_ += fmt::format("\t\t\t\t\tlet oldval_{}:{} = this.{};\n",  pPropertyDescription->getName(), typestr, pPropertyDescription->getName());

		std::string readName = datatype2nativetype(pPropertyDescription->getDataType()->getName());
		if (readName.size() > 0)
		{
			std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
			readName[0] = std::toupper(readName[0]);
		}
		else
		{
			KBE_ASSERT(false);
		}

		if (pPropertyDescription->getDataType()->type() == DATA_TYPE_FIXEDDICT)
		{
			readName = fmt::format("(EntityDef.id2datatypes[{}] as DATATYPE_{}).createFromStreamEx(stream)", 
				 pPropertyDescription->getDataType()->id(), pPropertyDescription->getDataType()->aliasName());
		}
		else if (pPropertyDescription->getDataType()->type() == DATA_TYPE_FIXEDARRAY)
		{
			if (strlen(pPropertyDescription->getDataType()->aliasName()) > 0)
			{
				readName = fmt::format("(EntityDef.id2datatypes[{}] as DATATYPE_{}).createFromStreamEx(stream)", 
					pPropertyDescription->getDataType()->id(), pPropertyDescription->getDataType()->aliasName());
			}
			else
			{
				readName = fmt::format("(EntityDef.id2datatypes[{}] as DATATYPE_AnonymousArray_{}).createFromStreamEx(stream)", 
					pPropertyDescription->getDataType()->id(),pPropertyDescription->getDataType()->id());
			}
		}
		else
		{
			if (readName == "Uint64" || readName == "Int64") {
				readName = fmt::format("stream.Read{}().toBigInt()", readName);
			}
			else {
				readName = fmt::format("stream.Read{}()", readName);
			}
			
		}

		sourcefileBody_ += fmt::format("\t\t\t\t\tthis.{} = {};\n", pPropertyDescription->getName(), readName);

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\n\t\t\t\t\tif(prop!.isBase())\n\t\t\t\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\tif(this.{}inited)\n", ownstr);
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\tthis.on{}Changed(oldval_{});\n\t\t\t\t\t\t}}\n", name, pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\t\telse\n\t\t\t\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\tif(this.{}inWorld)\n", ownstr);
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\tthis.on{}Changed(oldval_{});\n", name, pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t\tdefault:\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
	sourcefileBody_ += fmt::format("\t\t\t}};\n");

	sourcefileBody_ += fmt::format("\t\t}}\n");
	sourcefileBody_ += "\t}\n";

	// 处理属性callPropertysSetMethods
	sourcefileBody_ += fmt::format("\n\tpublic override callPropertysSetMethods(){{\n");
	sourcefileBody_ += fmt::format("\t\tlet sm:ScriptModule = EntityDef.moduledefs[\"{}\"];\n", pEntityScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\tlet pdatas = sm.idpropertys;\n\n");

	propIter = clientPropertys.begin();
	for (; propIter != clientPropertys.end(); ++propIter)
	{
		PropertyDescription* pPropertyDescription = propIter->second;

		std::string typestr;

		if (std::string("spaceID") == pPropertyDescription->getName())
			continue;

		if (std::string("position") == pPropertyDescription->getName() ||
			std::string("direction") == pPropertyDescription->getName())
		{
#ifdef CLIENT_NO_FLOAT
			typestr = "Vector3Int";
#else
			typestr = "Vector3";
#endif
		}
		else
		{
			std::string findstr = fmt::format(" {}:", pPropertyDescription->getName());
			std::string::size_type fpos2 = sourcefileBody_.find(findstr);
			std::string::size_type fpos1 = sourcefileBody_.find(" ", fpos2 + 1);
			// 这里获取类型，要处理
			typestr.assign(sourcefileBody_.begin() + fpos2 + findstr.length(), sourcefileBody_.begin() + fpos1);
		}

		if (pPropertyDescription->getDataType()->type() == DATA_TYPE_ENTITY_COMPONENT)
		{
			sourcefileBody_ += fmt::format("\t\tthis.{}!.callPropertysSetMethods();\n\n", pPropertyDescription->getName());
		}
		else
		{
			sourcefileBody_ += fmt::format("\t\tlet oldval_{}:{} = this.{};\n", pPropertyDescription->getName(), typestr, pPropertyDescription->getName());

			std::string name = pPropertyDescription->getName();
			name[0] = std::toupper(name[0]);

			sourcefileBody_ += fmt::format("\t\tlet prop_{}:Property = pdatas[{}];\n", pPropertyDescription->getName(), (pEntityScriptDefModule->usePropertyDescrAlias() ?
				pPropertyDescription->aliasID() : pPropertyDescription->getUType()));

			sourcefileBody_ += fmt::format("\t\tif(prop_{}.isBase()){{\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\tif(this.{}inited && !this.{}inWorld)\n", ownstr, ownstr);
			sourcefileBody_ += fmt::format("\t\t\t\tthis.on{}Changed(oldval_{});\n", name, pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t}}\n\t\telse\n\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\tif(this.{}inWorld)\n\t\t\t{{\n", ownstr);
			sourcefileBody_ += fmt::format("\t\t\t\tif(prop_{}.isOwnerOnly() && !this.{}IsPlayer())\n\t\t\t\t{{\n\t\t\t\t}}\n\t\t\t\telse\n\t\t\t\t{{\n", pPropertyDescription->getName(), ownstr);
			sourcefileBody_ += fmt::format("\t\t\t\t\tthis.on{}Changed(oldval_{});\n\t\t\t\t}}\n", name, pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t}}\n\t\t}}\n\n");
		}
	}

	sourcefileBody_ += "\t}\n";

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityPropertyComponent(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();
	
	sourcefileBody_ += fmt::format("\tpublic {}:{}{} | null  = null;\n", pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix,
		pEntityComponentType->pScriptDefModule()->getName());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_INT8(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number  = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:number){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_INT16(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number  = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:number){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_INT32(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number  = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:number){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_INT64(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:bigint  = {}n;\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:bigint){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_UINT8(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number  = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:number){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_UINT16(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number  = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:number){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_UINT32(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number  = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:number){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_UINT64(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:bigint  = {}n;\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:bigint){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_FLOAT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number  = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:number){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_DOUBLE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:number  = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:number){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_STRING(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:string = \"{}\";\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : ""));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:string){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_UNICODE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:string = \"{}\";\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : ""));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:string){{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_PYTHON(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKTypeScript::writeEntityProperty_PYTHON(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_PY_DICT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKTypeScript::writeEntityProperty_PY_DICT(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_PY_TUPLE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKTypeScript::writeEntityProperty_PY_TUPLE(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_PY_LIST(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKTypeScript::writeEntityProperty_PY_LIST(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_BLOB(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic {}:Uint8Array = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Uint8Array(0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:Uint8Array) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_ARRAY(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	if (std::string("ARRAY") == pPropertyDescription->getDataTypeName())
	{
		std::string s = sourcefileBody_;
		sourcefileBody_ = "";

		bool ret = writeTypeItemType_ARRAY(pPropertyDescription->getName(), pPropertyDescription->getDataType()->aliasName(), pPropertyDescription->getDataType());
		std::vector<std::string> values;
		KBEngine::strutil::kbe_splits(sourcefileBody_, " ", values);
		sourcefileBody_ = s + sourcefileBody_;

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:{}) {{}}\n", name, values[1]);
		return ret;
	}
	else
	{
		sourcefileBody_ += fmt::format("\tpublic {}:{}  = new {}();\n", pPropertyDescription->getName(), pPropertyDescription->getDataTypeName(),
			pPropertyDescription->getDataTypeName());

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:{}) {{}}\n", name, pPropertyDescription->getDataTypeName());
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_FIXED_DICT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:{} = new {}();\n", pPropertyDescription->getName(), pPropertyDescription->getDataTypeName(),
		pPropertyDescription->getDataTypeName());

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:{}) {{}}\n", name, pPropertyDescription->getDataTypeName());
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_VECTOR2(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector2Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector2Int(0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector2Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\tpublic {}:Vector2 = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector2(0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:Vector2) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_VECTOR3(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector3Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector3Int(0, 0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector3Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\tpublic {}:Vector3 = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector3(0, 0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:Vector3) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_VECTOR4(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector4Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector4Int(0, 0, 0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector4Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\tpublic {}:Vector4 = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector4(0, 0, 0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:Vector4) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityProperty_ENTITYCALL(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\tpublic {}:Uint8Array = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Uint8Array(0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\tpublic on{}Changed(oldValue:Uint8Array) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityMethod(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, MethodDescription* pMethodDescription, const char* fillString)
{
	sourcefileBody_ += fmt::format("\tpublic abstract {}({}); \n", pMethodDescription->getName(), fillString);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityMethodArgs_ARRAY(FixedArrayType* pFixedArrayType, std::string& stackArgsTypeBody, const std::string& childItemName)
{
	// 对于匿名数组需要解析，否则直接填类型名称
	if (childItemName.size() == 0 || childItemName[0] == '_')
	{
		std::string typeStr;
		getArrayType(pFixedArrayType, typeStr);
		stackArgsTypeBody += typeStr;
	}
	else
	{
		stackArgsTypeBody += childItemName;
	}

	return true;
}
 
//-------------------------------------------------------------------------------------
bool ClientSDKTypeScript::writeEntityMethodArgs_Const_Ref(DataType* pDataType, std::string& stackArgsTypeBody)
{
	return true;
}


//-------------------------------------------------------------------------------------
}
